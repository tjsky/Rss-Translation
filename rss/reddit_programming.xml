<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Mon, 18 Aug 2025 21:16:13 GMT</lastBuildDate>
    <item>
      <title>优化信任</title>
      <link>https://www.reddit.com/r/programming/comments/1mtwxwk/optimising_for_trust/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/swoopsfromabove      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtwxwk/optimising_for_trust/</guid>
      <pubDate>Mon, 18 Aug 2025 20:06:46 GMT</pubDate>
    </item>
    <item>
      <title>交错以检索增强发电</title>
      <link>https://www.reddit.com/r/programming/comments/1mtv7h9/interleaving_for_retrieval_augmented_generation/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/_srbhr_      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtv7h9/interleaving_for_retrieval_augmented_generation/</guid>
      <pubDate>Mon, 18 Aug 2025 19:02:59 GMT</pubDate>
    </item>
    <item>
      <title>帮助编码</title>
      <link>https://www.reddit.com/r/programming/comments/1mtuzhw/help_with_coding/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  我的大学研究算法和数据结构。我知道C的语法，并且我知道算法。但是，当涉及到这两件事时 - 我的大脑关闭。如果我被告知要编码一些东西，我什么也不做。我知道Dijkstra的算法是如何工作的，我可以在纸上的图表上做到这一点，但我根本无法编码！请帮助我解决这个问题。我将非常感激，它将挽救我的生命  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/mdzdva     [link]   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtuzhw/help_with_coding/</guid>
      <pubDate>Mon, 18 Aug 2025 18:55:00 GMT</pubDate>
    </item>
    <item>
      <title>logmod：ANSI C中的模块化记录框架（无全球或隐藏的mallocs）</title>
      <link>https://www.reddit.com/r/programming/comments/1mtsvgr/logmod_a_modular_logging_framework_in_ansi_c/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;   hey  r/programming ！！ 始终在C项目中困扰我的一件事：我可能会依靠隐藏的全局范围 我试图回答： logger既避免了 结果是什么样的？保持ANSI C且不会动态分配内存的记录库。以下是关键思想：   默认情况下没有全球状态  - 您明确地通过日志记录上下文； if you’re lazy, there’s still a fallback logger that kicks in when you pass NULL. Zero dynamic allocation – you pre‑allocate a table of logger structs and hand that to logmod_init. Works in both C89 and C99 – variadic macros for C99 and a tuple‑style logmod_nlog for old compilers. Custom labels and colours – define your own log levels starting from LOGMOD_LEVEL_CUSTOM, register them via logmod_logger_set_callback, and optionally colourise output. Thread‑safety and callbacks – supply a custom lock function for multi‑threaded logging, and hook into the logging pipeline to augment or filter messages. Configurable options – toggle console output, set a logfile, enable colours, or decide whether to show the application/context IDs.  Examples  不带全球的初始化：    #include; logmod.h; struct logmod logmod; struct logmod_logger表[4]; // PRE -OLACTARE LOGMOD_INIT（＆amp; logMod，&#39;app＆quot＆quot＆quot，table，4）; struct logmod_logger *net = logmod_get_logger（＆amp; logmod，&#39;&#39;network; quot＆quot; logmod_log（info，net，“连接到服务器％s＆quot”，主机）;    使用后式记录器（可选）：     logmod_log（warn，null，null，; quot&#39;nto config config confiend confiend confiend confiend confiend confiend confience offient offions; quote; quote; //使用内置的后备   定义自定义标签和颜色：     enum {logmod_level_http = logmod_level_level_custom，logmod_level_test};静态常规struct logmod_label custy_labels [] = {{{＆quot; http; logmod_label_color（常规，前景，蓝色），0}，{; void my_callback(const struct logmod_logger *logger, const struct logmod_info *info, const char *fmt, va_list args) { // custom handling... // return LOGMOD_OK to suppress default logging, or LOGMOD_OK_CONTINUE to augment } size_t num_labels = sizeof(custom_labels) / sizeof *custom_labels; logmod_logger_set_callback（net，custom_labels，num_labels，my_callback）; logmod_log（收到的http，net，net，net，http请求：％s＆quort; url）; logmod_log（在测试模式下运行测试，net，&#39;）;    切换颜色并设置logfile：     struct logmod_options opts opts = {.logfile = fopen（app.log; logmod_set_options（＆amp; logmod，opts）; //所有记录器logmod_logger_set_color的默认值（net，0）; //禁用此  外卖 挑战是使其便于携带和符合ANSI -C的挑战，同时避免了全球状态和隐藏的分配。它变成了几百行代码，但刮擦了特定的瘙痒。如果您喜欢挖掘低级设计交易，您可能会发现它很有趣。如果您需要JSON记录或远程接收器，不是。提交由＆＃32; /u/u/lucasmull      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtsvgr/logmod_a_modular_logging_framework_in_ansi_c/</guid>
      <pubDate>Mon, 18 Aug 2025 17:39:06 GMT</pubDate>
    </item>
    <item>
      <title>第41天：如何像专业人士一样保护您的node.js应用</title>
      <link>https://www.reddit.com/r/programming/comments/1mtpf85/day_41_how_to_secure_your_nodejs_app_like_a_pro/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/myssiriouseye8494     [link]   ＆＃32;  &lt;a href =“ https://www.reddit.com/r/programming/comments/1mtpf85/day_41_how_to_to_secure_your_your_your_nodejs_app_app_app_app_a _a_a_a_a_pro/]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtpf85/day_41_how_to_secure_your_nodejs_app_like_a_pro/</guid>
      <pubDate>Mon, 18 Aug 2025 15:34:59 GMT</pubDate>
    </item>
    <item>
      <title>默认情况下不变：如何避免OOP中隐藏的状态错误</title>
      <link>https://www.reddit.com/r/programming/comments/1mtm2fn/immutable_by_default_how_to_avoid_hidden_state/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/backendtea       [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtm2fn/immutable_by_default_how_to_avoid_hidden_state/</guid>
      <pubDate>Mon, 18 Aug 2025 13:28:50 GMT</pubDate>
    </item>
    <item>
      <title>汇编不仅用于编程语言</title>
      <link>https://www.reddit.com/r/programming/comments/1mtm0hv/compilation_isnt_just_for_programming_languages/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/Adventurous-salt8514      [link]  ＆＃32;   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtm0hv/compilation_isnt_just_for_programming_languages/</guid>
      <pubDate>Mon, 18 Aug 2025 13:26:39 GMT</pubDate>
    </item>
    <item>
      <title>为快乐而建立不仅仅是为了工作</title>
      <link>https://www.reddit.com/r/programming/comments/1mtlk71/build_for_joy_not_just_for_work/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  如何通过激情构建工艺  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/livid_sign9681      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtlk71/build_for_joy_not_just_for_work/</guid>
      <pubDate>Mon, 18 Aug 2025 13:08:13 GMT</pubDate>
    </item>
    <item>
      <title>使不可能的状态不可能：使用功能依赖注入的类型安全域建模</title>
      <link>https://www.reddit.com/r/programming/comments/1mtkwli/making_impossible_states_impossible_typesafe/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/cekrem      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtkwli/making_impossible_states_impossible_typesafe/</guid>
      <pubDate>Mon, 18 Aug 2025 12:40:40 GMT</pubDate>
    </item>
    <item>
      <title>员工+佳能：无权领导工具</title>
      <link>https://www.reddit.com/r/programming/comments/1mtki6p/the_staff_canon_tools_for_leading_without/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/bezomaxo      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtki6p/the_staff_canon_tools_for_leading_without/</guid>
      <pubDate>Mon, 18 Aug 2025 12:23:02 GMT</pubDate>
    </item>
    <item>
      <title>让我们做游戏吧！ 307：战场边界</title>
      <link>https://www.reddit.com/r/programming/comments/1mtiti1/lets_make_a_game_307_battlefield_boundaries/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/apeloverage      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtiti1/lets_make_a_game_307_battlefield_boundaries/</guid>
      <pubDate>Mon, 18 Aug 2025 11:00:40 GMT</pubDate>
    </item>
    <item>
      <title>2025年基准前端</title>
      <link>https://www.reddit.com/r/programming/comments/1mti1m8/benchmarking_frontends_in_2025/</link>
      <description><![CDATA[Hey r/programming, For a while now, I&#39;ve felt that our standard frontend benchmarks don&#39;t tell the whole story for the kind of complex, data-heavy apps many of us spend our days building.核心Web Vitals非常适合初始负载，并且流行的 JS-FrameWork-benchmark 很有用，但是它在测试时尺度应用程序中有两个主要限制：它禁止虚拟化/缓冲渲染，并且在造成沉重的背景时，它在造成的    &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  &gt; &gt; &gt; 。 我们的应用程序的弹性。 为了解决这个问题，我在过去的10天里花了一个新的基准测试标准，从而使用剧作家从头开始。目的是创建可以在持续的，同时进行的胁迫下提供可靠，高精度测量的东西。 构建这本身就是一个严肃的工程挑战，我想分享三个关键的经验教训：      是平行的trap：我的第一个本能是我的第一个本能是运行测试。这是一场灾难。最大化浏览器实例之间的CPU争论使结果偏向50％。 Lesson: Accurate performance benchmarking must be run serially (--workers=1). The Latency Chasm: The back-and-forth between the Node.js test runner and the browser introduced too much noise. 课程：测量必须是原子。我必须在单个 page.evaluate（）呼叫中包裹整个测试逻辑（触发操作 - 触发动作 - 等待条件 - 测量时间）  waitfor 函数（像大多数）使用长抽纸，这不足以进行性能测量。您无法使用30ms的轮询间隔测量20ms事件。 课程：不信任投票。我必须使用 mutationObserver 在 Exccent 时刻停止计时器。我创建的框架（neo.mjs）。我声称，从主线程中卸载逻辑可以解决主要的性能瓶颈，社区正确地要求提供证明。该基准是证明。  结果  到目前为止，最有趣的测试是针对行业领先的AG网格的新的Neo.mjs网格（在React App中）。当执行重型操作（例如将视口从50列调整为100,000行）时，结果鲜明：      react + ag react + ag grid： 〜3,000-5,5,500ms UI更新时间。       neo.mjs：   〜400ms Ui time。性能差异，取决于浏览器。 这不是对AG网格的起诉，这是一件很棒的工程。这是一个有力的数据点，显示了一个单线读取范式施加的建筑天花板。即使是一流的组件，最终也受到阻塞的主线程的限制。 这是一个开源项目，我希望开始就我们如何更好地衡量和构建“居住在”中的对话。网络。我很想获得有关方法和结果的反馈。   全文（“为什么”）：  https://tobiasuhlig.medium.com/benchmarking-frontends-in-2025-f6bbf43b7721?source=friends = friends_links_link＆amp; sk = af0f2c6745a7ca49999993bc0ae60ae60ae60ae60AdAdaebb40ebb4   github repo（“如何”  - 代码，方法论，结果）：  https://github.com/neomjs/neomjs/neomjs/neomjs/benchmarks/benchmarks  href =“ https://neomjs.com/dist/production/examples/grid/bigdata/index.html“  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/tobiasuhlig      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mti1m8/benchmarking_frontends_in_2025/</guid>
      <pubDate>Mon, 18 Aug 2025 10:16:25 GMT</pubDate>
    </item>
    <item>
      <title>LLM测试策略，来自OpenAI，Google，拟人化，Meta</title>
      <link>https://www.reddit.com/r/programming/comments/1mthzzm/llm_testing_strategies_from_openai_google/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/azilentech      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mthzzm/llm_testing_strategies_from_openai_google/</guid>
      <pubDate>Mon, 18 Aug 2025 10:13:53 GMT</pubDate>
    </item>
    <item>
      <title>内容 - 可调的存储（CAS）</title>
      <link>https://www.reddit.com/r/programming/comments/1mtg9rn/contentaddressable_storage_cas/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/vannam0511      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtg9rn/contentaddressable_storage_cas/</guid>
      <pubDate>Mon, 18 Aug 2025 08:28:53 GMT</pubDate>
    </item>
    <item>
      <title>NUMA是新网络：每个插座内存模型如何重塑微服务放置</title>
      <link>https://www.reddit.com/r/programming/comments/1mt8qjj/numa_is_the_new_network_how_persocket_memory/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  探讨非统一内存访问（numa）如何重塑微服务放置。  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/mqian41     [link]   [commist]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mt8qjj/numa_is_the_new_network_how_persocket_memory/</guid>
      <pubDate>Mon, 18 Aug 2025 01:34:23 GMT</pubDate>
    </item>
    </channel>
</rss>