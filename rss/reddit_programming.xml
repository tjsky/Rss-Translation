<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Tue, 14 Oct 2025 03:32:34 GMT</lastBuildDate>
    <item>
      <title>用于数学模拟的 Python 或 C++</title>
      <link>https://www.reddit.com/r/programming/comments/1o64qc8/python_or_c_for_math_simulations/</link>
      <description><![CDATA[我已经编码了近 9 年了，我想说我真的很擅长，我理解了很多东西。作为一名自学成才的开发人员，我仍在学习，现在我在大学学习数学（精算科学），因为我真的很喜欢它。问题是，我喜欢将实现数学算法作为一种爱好，阅读论文，理解它们，然后用它们进行模拟或创建东西。 但我在 Python 与 Pygame 和 C++ 之间陷入困境。我都用过，它们都很棒。我知道 C++ 更快，但 Python 的开发速度更快。不过，这是我的问题：当我使用 Python 时，我对不使用 C++ 和 OpenGL 感到害怕，因为我真的想说我从头开始实现了一些东西。但当我切换到 C++ 时，我一直在想用 Python 会更快。这些只是我真正喜欢的地下室项目，我知道这种感觉可能有些奇怪，但我无法摆脱它。 我应该做什么？   由   提交/u/Dramatic_Disaster837   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o64qc8/python_or_c_for_math_simulations/</guid>
      <pubDate>Tue, 14 Oct 2025 03:22:36 GMT</pubDate>
    </item>
    <item>
      <title>🚶‍♂️ 你是否厌倦了被束缚在桌子上编码？</title>
      <link>https://www.reddit.com/r/programming/comments/1o64cpy/have_you_tired_of_coding_being_chained_to_a_desk/</link>
      <description><![CDATA[好吧，我厌倦了将代码束缚在桌子上 当我离开计算机时，我想到的每一个想法。走到外面。坐在安静的地方。 这时，最好的提示出现了 - 那些真正重要的提示。 但是我的设置 - 我的整个“语言世界” - 都在我办公桌上的黑盒子里。副驾驶、工作空间、历史，一切。 这就像创造力和代码被困在不同的世界中。 所以我决定将它们连接起来。 ⚙️ 我在思想之间建立了一座桥梁 和代码 不是云 IDE。 不是 SSH。 不是远程桌面。 手机和桌面 VS Code 之间的直接加密连接 -相同的环境，相同的上下文，相同的 Copilot 会话。 这就像将我的编码大脑放在口袋里。我可以走到外面，打开手机， 发送提示，获取答案，提交文件，或者只是用代码思考 - 任何地方。 没有中间人。服务器上没有数据。 只有我和我的环境，通过空中交谈。 💡 然后点击了一些东西 这与生产力无关。 这是关于自由。 当我不再将 VS Code 视为一个应用程序 并开始将其视为跟随我的运行时时， 一切 改变了。 突然之间，我的工具不再存在于我的机器上。 它们与我一起生活。 🧩 更深入的认识 我们不断发明新的语言和框架 - 但真正的演变可能不在语法中。 它可能存在。 一种不存在于单一语言上的语言 设备。 一个行为类似于分布式大脑的 IDE。 一个运行时，可以了解您所在的位置，而不仅仅是您键入的内容。 我认为这就是开发的方向。 不是“云编码”。不是“AI 结对编程”。 而是个人环境 - 当你移动时思维的延伸。 🧠 我称我的 VSCoder Copilot 这是我现在每天使用的东西。 我可以在咖啡馆提示 Copilot，在公园里调整文件， 或在半睡半醒时在电脑上进行实验。  不是因为它实用 -而是因为第一次，我的工具感觉有活力。 老实说......一旦你像这样编码，你就无法回去。   由   提交 /u/vscoderCopilot   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o64cpy/have_you_tired_of_coding_being_chained_to_a_desk/</guid>
      <pubDate>Tue, 14 Oct 2025 03:03:59 GMT</pubDate>
    </item>
    <item>
      <title>分享一个设计模式思想：Reflector Pattern</title>
      <link>https://www.reddit.com/r/programming/comments/1o63hp4/sharing_a_design_pattern_idea_reflector_pattern/</link>
      <description><![CDATA[在开发虚拟文件系统时，我遇到了策略和外观等模式的常见限制，这些模式在纸面上很好，但当您需要真正的运行时模块化时就很尴尬。 所以我想出了一种我称之为反射器模式的东西。  核心思想：  每个实体（或外观）都实现与其处理程序相同的接口 处理程序包含所有数据和逻辑，并实现相同的接口 外观“反映”接口，覆盖方法并将它们直接委托给处理程序 处理程序可以在运行时交换 （热插拔）而不破坏外观或客户端代码 每个处理程序都做好一件事，完全符合 SOLID 规范   为什么有效： 客户端仅与接口对话。实体不“拥有”逻辑或数据，它只是镜像 API 并动态路由调用。这为您提供了 完全模块化、多态性和干净的解耦。 它就像一个外观 + 策略，但外观实际上实现了与其策略相同的接口，成为其行为的“反射器”。 此外，与继承上的组合不同，它允许您重用行为，但仍然向消费者公开内部组件。反射器模式“反射”接口，因此实体是其处理程序的真正多态代理，完全隐藏实现并允许无缝运行时交换。  这是一个示例： ```java // unrays 代码 - 反射器模式 // 处理程序（策略）类 WalkHandler 实现 IMove { 移动() -&gt; print(&quot;Walking&quot;) } class SwordAttackHandler 实现 IAttack { Attack() -&gt; print(“挥剑”) } // 门面实体实现相同的接口 class GameCharacter 实现 IMove, IAttack { moveHandler: IMove AttackHandler: IAttack move() -&gt; moveHandler.move() Attack() -&gt;; AttackHandler.attack()  } // 使用 Hero = new GameCharacter() Hero.moveHandler = new WalkHandler() Hero.attackHandler = new SwordAttackHandler() consumer.use(hero) // 只看到 IMove &amp; IAttack接口hero.move() //行走hero.attack() //挥剑 //运行时热插拔hero.moveHandler = new RunHandler()hero.move() //运行 ```  我还没有找到任何与此完全匹配的现有模式。好奇是否有人见过类似的东西，或者如果这个 确实是新的。我也希望得到一些关于这种方法的反馈，它可能有缺陷，但我认为它在某些情况下可能有用。我来这里是为了学习和迭代这个想法，所以在评论中要尊重:)  注意：我对我的英文解释不是100%有信心，所以我使用人工智能来帮助润色文本。 完全反映了我最初的想法，我可以向你保证，人工智能与这个概念本身无关，只是帮助我解释清楚。如果您想联系我，可以通过我的 GitHub 联系我。我真诚地感谢您阅读我的帖子。  标签：#ReflectorPattern #SoftwareArchitecture #DesignPatterns #CleanArchitecture #SOLIDPrinciples #ModularDesign #RuntimePolymorphism #Programming #CodeDesign #ILoveCats #CodingIsLife #HotSwapEverything   由   提交 /u/Mysticatly   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o63hp4/sharing_a_design_pattern_idea_reflector_pattern/</guid>
      <pubDate>Tue, 14 Oct 2025 02:22:11 GMT</pubDate>
    </item>
    <item>
      <title>集体矩阵乘法 – JAX Pallas:Mosaic GPU</title>
      <link>https://www.reddit.com/r/programming/comments/1o5yncg/collective_matrix_multiplication_jax_pallasmosaic/</link>
      <description><![CDATA[ 由   提交 /u/mttd   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5yncg/collective_matrix_multiplication_jax_pallasmosaic/</guid>
      <pubDate>Mon, 13 Oct 2025 22:40:47 GMT</pubDate>
    </item>
    <item>
      <title>Java 字符串内部结构 - 存储、实习、串联和性能</title>
      <link>https://www.reddit.com/r/programming/comments/1o5yf4o/java_strings_internals_storage_interning/</link>
      <description><![CDATA[ 由   提交 /u/One_Being7941   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5yf4o/java_strings_internals_storage_interning/</guid>
      <pubDate>Mon, 13 Oct 2025 22:31:01 GMT</pubDate>
    </item>
    <item>
      <title>反应编译器 v1.0</title>
      <link>https://www.reddit.com/r/programming/comments/1o5x90j/react_compiler_v10/</link>
      <description><![CDATA[ 由   提交 /u/alexeyr   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5x90j/react_compiler_v10/</guid>
      <pubDate>Mon, 13 Oct 2025 21:43:49 GMT</pubDate>
    </item>
    <item>
      <title>人工智能无法修复损坏的系统：2025 年 DORA 报告的教训</title>
      <link>https://www.reddit.com/r/programming/comments/1o5wxpz/ai_wont_fix_broken_systems_lessons_from_the_2025/</link>
      <description><![CDATA[更快的编码并不总是意味着更高的生产力。   由   提交/u/aviator_co  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5wxpz/ai_wont_fix_broken_systems_lessons_from_the_2025/</guid>
      <pubDate>Mon, 13 Oct 2025 21:31:35 GMT</pubDate>
    </item>
    <item>
      <title>Redis 上运行的 Lua 脚本存在严重漏洞 - CVE-2025-49844</title>
      <link>https://www.reddit.com/r/programming/comments/1o5rmrn/critical_vulnerability_in_lua_scripts_run_on/</link>
      <description><![CDATA[我想知道你们对将脚本语言引入键值存储的整个想法有何看法，以便您可以“高效且原子地在 Redis 中执行部分应用程序逻辑”。   由   提交/u/matt_112358  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5rmrn/critical_vulnerability_in_lua_scripts_run_on/</guid>
      <pubDate>Mon, 13 Oct 2025 18:18:15 GMT</pubDate>
    </item>
    <item>
      <title>测试并不能证明代码是正确的……他们只是同意它</title>
      <link>https://www.reddit.com/r/programming/comments/1o5rh32/tests_dont_prove_code_is_correct_they_just_agree/</link>
      <description><![CDATA[“测试并不能证明某件事是正确的，而是证明一段代码的行为方式与另一段代码认为它应该行为的方式相同。” 有一天，我在编写一些“完美通过”的测试时突然想到了这个想法。我意识到他们实际上并没有证明任何东西——只是确认我在两个地方的假设是匹配的。 当你的实现和测试都有相同的错误假设时，一切仍然会通过。绿色复选标记，虚假信心。 这让我重新思考测试的用途。它们并不是真正要证明真理——更多的是要锁定意图。一种说法是，“如果我改变这种行为，我想知道。” 棘手的部分是意图本身可能是错误的。 无论如何，这只是太多追求 100% 覆盖率的深夜的随机反映。很好奇你们都怎么想的——你们认为测试是验证、文档，还是只是控制混乱的护栏？   由   提交 /u/untypedfuture   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5rh32/tests_dont_prove_code_is_correct_they_just_agree/</guid>
      <pubDate>Mon, 13 Oct 2025 18:12:44 GMT</pubDate>
    </item>
    <item>
      <title>基于行的 Lisp 编辑</title>
      <link>https://www.reddit.com/r/programming/comments/1o5res3/linebased_lisp_editing/</link>
      <description><![CDATA[ 由   提交/u/aartaka  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5res3/linebased_lisp_editing/</guid>
      <pubDate>Mon, 13 Oct 2025 18:10:27 GMT</pubDate>
    </item>
    <item>
      <title>《星际迷航》中没有程序员</title>
      <link>https://www.reddit.com/r/programming/comments/1o5rdyg/there_are_no_programmers_in_star_trek/</link>
      <description><![CDATA[ 由   提交/u/Active-Fuel-49   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5rdyg/there_are_no_programmers_in_star_trek/</guid>
      <pubDate>Mon, 13 Oct 2025 18:09:42 GMT</pubDate>
    </item>
    <item>
      <title>技术债务：让开发人员现在更快乐，或者以后付出更多</title>
      <link>https://www.reddit.com/r/programming/comments/1o5nnoe/technical_debt_make_developers_happier_now_or_pay/</link>
      <description><![CDATA[ 由   提交/u/nosoyjohn  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5nnoe/technical_debt_make_developers_happier_now_or_pay/</guid>
      <pubDate>Mon, 13 Oct 2025 15:57:35 GMT</pubDate>
    </item>
    <item>
      <title>使用 Swift Subprocess 自动化所有事情</title>
      <link>https://www.reddit.com/r/programming/comments/1o5nm1t/automate_all_the_things_with_swift_subprocess/</link>
      <description><![CDATA[ 由   提交/u/jacobs-tech-tavern   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5nm1t/automate_all_the_things_with_swift_subprocess/</guid>
      <pubDate>Mon, 13 Oct 2025 15:55:58 GMT</pubDate>
    </item>
    <item>
      <title>如何使用人工智能帮助完成软件工程任务</title>
      <link>https://www.reddit.com/r/programming/comments/1o5kmc5/how_to_use_ai_to_help_with_software_engineering/</link>
      <description><![CDATA[ 由   提交 /u/gregorojstersek   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5kmc5/how_to_use_ai_to_help_with_software_engineering/</guid>
      <pubDate>Mon, 13 Oct 2025 14:04:53 GMT</pubDate>
    </item>
    <item>
      <title>汇编编程是残酷的，也是美丽的，甚至可能是通往更好人工智能的道路</title>
      <link>https://www.reddit.com/r/programming/comments/1o5jq1w/programming_in_assembly_is_brutal_beautiful_and/</link>
      <description><![CDATA[ 由   提交/u/wiredmagazine  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5jq1w/programming_in_assembly_is_brutal_beautiful_and/</guid>
      <pubDate>Mon, 13 Oct 2025 13:28:29 GMT</pubDate>
    </item>
    </channel>
</rss>