<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Tue, 19 Aug 2025 01:13:51 GMT</lastBuildDate>
    <item>
      <title>开源模型量化库可实现4倍压缩 - 寻找贡献者</title>
      <link>https://www.reddit.com/r/programming/comments/1mu3ump/open_source_model_quantization_library_achieving/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;      project ：带有新型级联进近方法的神经量化库    问题说明：当前的模型量化工具：      好（英语偏见） 需要专门的硬件（可访问性障碍）   技术解决方案：实现了级联量化管道，以防止“量化悬崖”问题：传统：FP16 -----＆GT; int4（巨大的精度下降=性能悬崖）级联：fp16-＆gt; int8  - ＆gt; int4（逐渐减少=保留性能）   架构概述：      阶段1 ：fp16→int8具有语言 - 静态校准     培训管道集成  部署：边缘优化推理内核     绩效指标：     压缩：4.2×（target：target：＆gt; gt; 3.5×）    98：98（98）。 ✅ 推论加速：3.2× 跨语性验证：13/15语言成功✅ 记忆足迹：jetson nano兼容✅ Dependencies:  Core: Python 3.8+, PyTorch, NumPy Optimization: Triton kernels, CUDA support Target: GPTQ integration, Marlin kernel optimization Testing: Comprehensive multi-language evaluation suite  Current Implementation状态：✅研究原型（经过验证的方法）✅演示管道（所有实现的指标）🚧生产核心（GPTQ算法）🚧内核优化（MARLIN/TRITON）🚧多模型支持🚧包装分布＆amp; CI/C   贡献机会：    核心算法：GPTQ实施，优化数学        Testing: Hardware validation, benchmark suites DevOps: CI/CD, packaging, documentation  Code Quality Standards:  Type hints, comprehensive docstrings Unit tests with &gt;90% coverage Performance benchmarking suite Memory profiling integration Clear separation of research/production code  Why Contribute:  Impact: Democratize efficient AI deployment globally Learning: Deep dive into quantization, optimization, numerical computing Community: Work with全球研究人员和工程师 投资组合：开源ML基础设施经验    入门：存储库包括详细的设置说明，建筑文档和按经验水平标记的问题。乐于指导新贡献者。  讨论点：  我们应该优先考虑哪些模型体系结构？ 哪些部署方案最关键是最关键的？ 我们如何优化开发人员经验？现在，我们需要卓越的工程才能使其准备就绪。有兴趣建立高效AI部署的未来吗？  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/u/silver_raspberry_811      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mu3ump/open_source_model_quantization_library_achieving/</guid>
      <pubDate>Tue, 19 Aug 2025 00:42:10 GMT</pubDate>
    </item>
    <item>
      <title>使用Ebitengine（教程）处理鼠标和触摸屏输入</title>
      <link>https://www.reddit.com/r/programming/comments/1mu2gl8/handling_mouse_and_touchscreen_input_using/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/tslocum      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mu2gl8/handling_mouse_and_touchscreen_input_using/</guid>
      <pubDate>Mon, 18 Aug 2025 23:42:14 GMT</pubDate>
    </item>
    <item>
      <title>API Live Sync＃5：文件观看</title>
      <link>https://www.reddit.com/r/programming/comments/1mtzw34/api_live_sync_5_file_watching/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  在这篇文章中，我将带您介绍我们如何构建两个关键基础作品：一个文件观察系统和一个理解您的代码和API测试之间关系的集合存储。   &lt;！ -  sc_on-&gt;＆&gt; 32;提交由＆＃32; /u/u/evilhighlord      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtzw34/api_live_sync_5_file_watching/</guid>
      <pubDate>Mon, 18 Aug 2025 21:56:53 GMT</pubDate>
    </item>
    <item>
      <title>优化信任</title>
      <link>https://www.reddit.com/r/programming/comments/1mtwxwk/optimising_for_trust/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/swoopsfromabove      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtwxwk/optimising_for_trust/</guid>
      <pubDate>Mon, 18 Aug 2025 20:06:46 GMT</pubDate>
    </item>
    <item>
      <title>交错以检索增强发电</title>
      <link>https://www.reddit.com/r/programming/comments/1mtv7h9/interleaving_for_retrieval_augmented_generation/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/_srbhr_      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtv7h9/interleaving_for_retrieval_augmented_generation/</guid>
      <pubDate>Mon, 18 Aug 2025 19:02:59 GMT</pubDate>
    </item>
    <item>
      <title>第41天：如何像专业人士一样保护您的node.js应用</title>
      <link>https://www.reddit.com/r/programming/comments/1mtpf85/day_41_how_to_secure_your_nodejs_app_like_a_pro/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/myssiriouseye8494     [link]   ＆＃32;  &lt;a href =“ https://www.reddit.com/r/programming/comments/1mtpf85/day_41_how_to_to_secure_your_your_your_nodejs_app_app_app_app_a _a_a_a_a_pro/]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtpf85/day_41_how_to_secure_your_nodejs_app_like_a_pro/</guid>
      <pubDate>Mon, 18 Aug 2025 15:34:59 GMT</pubDate>
    </item>
    <item>
      <title>默认情况下不变：如何避免OOP中隐藏的状态错误</title>
      <link>https://www.reddit.com/r/programming/comments/1mtm2fn/immutable_by_default_how_to_avoid_hidden_state/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/backendtea       [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtm2fn/immutable_by_default_how_to_avoid_hidden_state/</guid>
      <pubDate>Mon, 18 Aug 2025 13:28:50 GMT</pubDate>
    </item>
    <item>
      <title>汇编不仅用于编程语言</title>
      <link>https://www.reddit.com/r/programming/comments/1mtm0hv/compilation_isnt_just_for_programming_languages/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/Adventurous-salt8514      [link]  ＆＃32;   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtm0hv/compilation_isnt_just_for_programming_languages/</guid>
      <pubDate>Mon, 18 Aug 2025 13:26:39 GMT</pubDate>
    </item>
    <item>
      <title>为快乐而建立不仅仅是为了工作</title>
      <link>https://www.reddit.com/r/programming/comments/1mtlk71/build_for_joy_not_just_for_work/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  如何通过激情构建工艺  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/livid_sign9681      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtlk71/build_for_joy_not_just_for_work/</guid>
      <pubDate>Mon, 18 Aug 2025 13:08:13 GMT</pubDate>
    </item>
    <item>
      <title>使不可能的状态不可能：使用功能依赖注入的类型安全域建模</title>
      <link>https://www.reddit.com/r/programming/comments/1mtkwli/making_impossible_states_impossible_typesafe/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/cekrem      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtkwli/making_impossible_states_impossible_typesafe/</guid>
      <pubDate>Mon, 18 Aug 2025 12:40:40 GMT</pubDate>
    </item>
    <item>
      <title>员工+佳能：无权领导工具</title>
      <link>https://www.reddit.com/r/programming/comments/1mtki6p/the_staff_canon_tools_for_leading_without/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/bezomaxo      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtki6p/the_staff_canon_tools_for_leading_without/</guid>
      <pubDate>Mon, 18 Aug 2025 12:23:02 GMT</pubDate>
    </item>
    <item>
      <title>让我们做游戏吧！ 307：战场边界</title>
      <link>https://www.reddit.com/r/programming/comments/1mtiti1/lets_make_a_game_307_battlefield_boundaries/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/apeloverage      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtiti1/lets_make_a_game_307_battlefield_boundaries/</guid>
      <pubDate>Mon, 18 Aug 2025 11:00:40 GMT</pubDate>
    </item>
    <item>
      <title>2025年基准前端</title>
      <link>https://www.reddit.com/r/programming/comments/1mti1m8/benchmarking_frontends_in_2025/</link>
      <description><![CDATA[Hey r/programming, For a while now, I&#39;ve felt that our standard frontend benchmarks don&#39;t tell the whole story for the kind of complex, data-heavy apps many of us spend our days building.核心Web Vitals非常适合初始负载，并且流行的 JS-FrameWork-benchmark 很有用，但是它在测试时尺度应用程序中有两个主要限制：它禁止虚拟化/缓冲渲染，并且在造成沉重的背景时，它在造成的    &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;  &gt; &gt; &gt; 。 我们的应用程序的弹性。 为了解决这个问题，我在过去的10天里花了一个新的基准测试标准，从而使用剧作家从头开始。目的是创建可以在持续的，同时进行的胁迫下提供可靠，高精度测量的东西。 构建这本身就是一个严肃的工程挑战，我想分享三个关键的经验教训：      是平行的trap：我的第一个本能是我的第一个本能是运行测试。这是一场灾难。最大化浏览器实例之间的CPU争论使结果偏向50％。 Lesson: Accurate performance benchmarking must be run serially (--workers=1). The Latency Chasm: The back-and-forth between the Node.js test runner and the browser introduced too much noise. 课程：测量必须是原子。我必须在单个 page.evaluate（）呼叫中包裹整个测试逻辑（触发操作 - 触发动作 - 等待条件 - 测量时间）  waitfor 函数（像大多数）使用长抽纸，这不足以进行性能测量。您无法使用30ms的轮询间隔测量20ms事件。 课程：不信任投票。我必须使用 mutationObserver 在 Exccent 时刻停止计时器。我创建的框架（neo.mjs）。我声称，从主线程中卸载逻辑可以解决主要的性能瓶颈，社区正确地要求提供证明。该基准是证明。  结果  到目前为止，最有趣的测试是针对行业领先的AG网格的新的Neo.mjs网格（在React App中）。当执行重型操作（例如将视口从50列调整为100,000行）时，结果鲜明：      react + ag react + ag grid： 〜3,000-5,5,500ms UI更新时间。       neo.mjs：   〜400ms Ui time。性能差异，取决于浏览器。 这不是对AG网格的起诉，这是一件很棒的工程。这是一个有力的数据点，显示了一个单线读取范式施加的建筑天花板。即使是一流的组件，最终也受到阻塞的主线程的限制。 这是一个开源项目，我希望开始就我们如何更好地衡量和构建“居住在”中的对话。网络。我很想获得有关方法和结果的反馈。   全文（“为什么”）：  https://tobiasuhlig.medium.com/benchmarking-frontends-in-2025-f6bbf43b7721?source=friends = friends_links_link＆amp; sk = af0f2c6745a7ca49999993bc0ae60ae60ae60ae60AdAdaebb40ebb4   github repo（“如何”  - 代码，方法论，结果）：  https://github.com/neomjs/neomjs/neomjs/neomjs/benchmarks/benchmarks  href =“ https://neomjs.com/dist/production/examples/grid/bigdata/index.html“  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/tobiasuhlig      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mti1m8/benchmarking_frontends_in_2025/</guid>
      <pubDate>Mon, 18 Aug 2025 10:16:25 GMT</pubDate>
    </item>
    <item>
      <title>LLM测试策略，来自OpenAI，Google，拟人化，Meta</title>
      <link>https://www.reddit.com/r/programming/comments/1mthzzm/llm_testing_strategies_from_openai_google/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/azilentech      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mthzzm/llm_testing_strategies_from_openai_google/</guid>
      <pubDate>Mon, 18 Aug 2025 10:13:53 GMT</pubDate>
    </item>
    <item>
      <title>内容 - 可调的存储（CAS）</title>
      <link>https://www.reddit.com/r/programming/comments/1mtg9rn/contentaddressable_storage_cas/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/vannam0511      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mtg9rn/contentaddressable_storage_cas/</guid>
      <pubDate>Mon, 18 Aug 2025 08:28:53 GMT</pubDate>
    </item>
    </channel>
</rss>