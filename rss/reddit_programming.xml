<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Sat, 02 Aug 2025 21:19:07 GMT</lastBuildDate>
    <item>
      <title>为什么您不应该将数据库视为集成平台</title>
      <link>https://www.reddit.com/r/programming/comments/1mfzkg8/why_you_shouldnt_treat_your_database_as_an/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/neoellefsen     [link]   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfzkg8/why_you_shouldnt_treat_your_database_as_an/</guid>
      <pubDate>Sat, 02 Aug 2025 19:51:08 GMT</pubDate>
    </item>
    <item>
      <title>如何在FastAPI中实施身份验证：完整的开发人员指南</title>
      <link>https://www.reddit.com/r/programming/comments/1mfy8j8/how_to_implement_authentication_in_fastapi_a/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  在FastApi中构建安全身份验证不必是一场噩梦。无论您是创建第一个API还是想要实现强大授权的经验丰富的开发人员，本指南都会引导您了解有关FastAPI身份验证所需的所有信息。 身份验证基本上是API门上的Bouncer，它检查谁试图进入以及是否允许他们进行。在本指南中，我们将构建一个完整的身份验证系统，该系统可以处理用户注册，登录，令牌管理，电子邮件验证，密码重置，甚至使用Google进行OAuth。  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/tholud_serve9696       [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfy8j8/how_to_implement_authentication_in_fastapi_a/</guid>
      <pubDate>Sat, 02 Aug 2025 18:54:14 GMT</pubDate>
    </item>
    <item>
      <title>Bold Devlog-七月摘要（JSON，DAP，LSP）</title>
      <link>https://www.reddit.com/r/programming/comments/1mfwqfs/bold_devlog_july_summary_json_dap_lsp/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/levodelellis      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfwqfs/bold_devlog_july_summary_json_dap_lsp/</guid>
      <pubDate>Sat, 02 Aug 2025 17:50:40 GMT</pubDate>
    </item>
    <item>
      <title>实施重试机制-Java面试问题</title>
      <link>https://www.reddit.com/r/programming/comments/1mfutvw/implement_retry_mechanism_java_interview_question/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  实现重试机制-Java访谈问题 问题 您正在设计需要与外部API通信的服务，偶尔由于暂时的网络问题而失败。描述如何实现重试机制来处理这些失败。 跟进，说明何时使用断路器而不是重试机制，并讨论将两者一起实现的场景。    https://javabulletin.substack.com/p/imemplement-retry-mechanism-mechanism-mechanism-java-intry-mechanism-java-interva-interva-interva-interva-interview 提交由＆＃32; /u/u/u/decuntional-ad2036     *&gt;] ＆＃32;   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfutvw/implement_retry_mechanism_java_interview_question/</guid>
      <pubDate>Sat, 02 Aug 2025 16:31:00 GMT</pubDate>
    </item>
    <item>
      <title>Fastapi的工作方式</title>
      <link>https://www.reddit.com/r/programming/comments/1mftlq7/how_fastapi_works/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;   hood下的fastapi   &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/tholud_serve9696        [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mftlq7/how_fastapi_works/</guid>
      <pubDate>Sat, 02 Aug 2025 15:39:46 GMT</pubDate>
    </item>
    <item>
      <title>为期一周的深入研究双模式模板引擎（运行时解析器与构建时间AST编译器）</title>
      <link>https://www.reddit.com/r/programming/comments/1mfthww/a_oneweek_deep_dive_into_building_a_dualmode/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  嘿 r/programming ， 我刚刚出现在一个令人着迷的，强烈的一周中，并想分享建筑的旅程。面临的挑战是一个经典的挑战：您如何设计一个在开发环境中非常易于使用的系统，而且对生产进行了无情的优化？ 上下文是我在（neo.mjs）上使用的开源网络框架的UI模板引擎。我们的目标是提供一种直观的，类似于HTML的语法，需要在开发中零构建步骤。 这导致了双模式体系结构，具有两个完全不同的实现同一输入的实现。 模式1：运行时解释器（开发）                           ”小路。 We used a standard language feature (JavaScript&#39;s Tagged Template Literals) so developers can just write html...`` and see it work instantly.  Input: A template string with embedded dynamic values. Process: At runtime, a tag function intercepts the call.它动态导入一个解析器库（Parse5），该库将字符串转换为AST。然后，我们穿越了AST来产生我们的内部vdom结构。 折衷：这是一种很棒的开发人员体验，但它需要向客户运送约176kb的解析器。生产无法接受。  模式2：构建时间编译器（用于生产） 这是乐趣的地方。目的是产生与运行时模式完全相同的vdom结构，但是在零运行时开销。  输入：开发人员的原始源代码文件。  Process：我们构建了一个脚本，该脚本用作迷你编译器，使用Acorn将JS源分析为AST。  它遍历AST，寻找我们的HTML标记模板节点。 它提取模板的字符串和表达式。这里的关键挑战是$ {this.name}之类的表达式在构建时间没有任何含义，因此我们捕获了原始代码字符串“ this.name”。并将其包裹在特别的占位符中。 它使用与运行时模式相同的核心解析逻辑将模板转换为可序列化的vdom对象，现在使用占位符代替真实值。 它然后将Vdom对象转换为有效的Javascript AST AST AST OBSICT EXPRACTISPRESSION EXPRESSECTEXPRESSION NODE。  最后，它用这个新的，优化的对象节点。 最后，它代替了源代码中的原始模板节点。 然后，修改后的AST然后将其写入文件中，然后使用ADRESTRING。解析器。    整个系统（从概念到完成）在所有构建环境中，都在不到一周的时间内建立了整个系统，就好像开发人员用手编写了优化的vdom。我们写了一个非常详细的“在引擎盖下”。解释整个过程的指南。 您可以在此处查看完整的发行说明（带有实时演示）：架构的深入指南在这里： https://github.com/neomjs/neo/blob/dev/learn/guides/uibuildingblocks/htmltemplatesunderhood.md    我对这个“ dev vs. prod”着迷。软件设计中的二分法。我很想听听您对这种双模式方法的想法。还有其他用于解决此问题的模式吗？我可能没有考虑过这种AST替换的潜在陷阱是什么？  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/tobiasuhlig     [link]     [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfthww/a_oneweek_deep_dive_into_building_a_dualmode/</guid>
      <pubDate>Sat, 02 Aug 2025 15:35:24 GMT</pubDate>
    </item>
    <item>
      <title>UNIKERNEL指南：建立和部署轻巧的安全应用</title>
      <link>https://www.reddit.com/r/programming/comments/1mfrycs/unikernel_guide_build_deploy_lightweight_secure/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/ieyberg      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfrycs/unikernel_guide_build_deploy_lightweight_secure/</guid>
      <pubDate>Sat, 02 Aug 2025 14:31:24 GMT</pubDate>
    </item>
    <item>
      <title>如何通过缓存变暖优化性能？</title>
      <link>https://www.reddit.com/r/programming/comments/1mfr3tr/how_to_optimize_performance_with_cache_warming/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/scalableThread        [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfr3tr/how_to_optimize_performance_with_cache_warming/</guid>
      <pubDate>Sat, 02 Aug 2025 13:53:44 GMT</pubDate>
    </item>
    <item>
      <title>React博客文章：反思和反应</title>
      <link>https://www.reddit.com/r/programming/comments/1mfpgyg/the_react_blog_post_reflections_and_reactions/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  第2部分博客文章“提交由＆＃32; /u/u/u/boggylp      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfpgyg/the_react_blog_post_reflections_and_reactions/</guid>
      <pubDate>Sat, 02 Aug 2025 12:34:52 GMT</pubDate>
    </item>
    <item>
      <title>PatchWorkos：一个从划痕的非posix OS严格遵守我一直在工作的“一切都是文件”理念。</title>
      <link>https://www.reddit.com/r/programming/comments/1mfoxwc/patchworkos_a_fromscratch_nonposix_os_strictly/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  拼布基于来自UNIX，PLAN9和DOS在内的许多不同地方的想法。严格遵守“一切都是文件”启发是受Plan9的启发，同时从其某些怪异的选择中散发出来，例如PatchWork支持硬链接，Plan9没有。 所有内容包括管道，插座，共享存储器，共享内存以及更多通过文件系统/dev&gt;/dev /code&gt;/proc 和/net net /net/local/seqpacket 文件来创建本地套接字。插座是在读书中详细讨论的。 拼布的一个独特功能是其文件标志系统，它旨在为外壳提供更多的功能（检查读书文件以获取示例），并更好地将顾虑分开与内核分开，例如，诸如prective foremers the poserive oferement oferement oferement oferement oferement oferement forem posentive forement of            和无滴答的内核，SMP，恒定时间调度，恒定时间虚拟内存管理等。   readme  有更多的详细信息，筛选，示例，示例和一些简单的指导。很想听听您的想法，建议或回答问题！  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/kn_9296      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfoxwc/patchworkos_a_fromscratch_nonposix_os_strictly/</guid>
      <pubDate>Sat, 02 Aug 2025 12:07:13 GMT</pubDate>
    </item>
    <item>
      <title>压缩冰岛名称的变形模式为3.27 kb trie</title>
      <link>https://www.reddit.com/r/programming/comments/1mfoh6z/compressing_icelandic_name_declension_patterns/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/xlex97     [link&gt; link&gt; [link]   [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfoh6z/compressing_icelandic_name_declension_patterns/</guid>
      <pubDate>Sat, 02 Aug 2025 11:41:50 GMT</pubDate>
    </item>
    <item>
      <title>作为氛围编码时代的工程师蓬勃发展</title>
      <link>https://www.reddit.com/r/programming/comments/1mfnk76/thriving_as_an_engineer_in_the_era_of_vibe_coding/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/thegrey_m      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfnk76/thriving_as_an_engineer_in_the_era_of_vibe_coding/</guid>
      <pubDate>Sat, 02 Aug 2025 10:47:24 GMT</pubDate>
    </item>
    <item>
      <title>[p]从刮擦中实施了研究论文“记住变压器”，并在建筑和定制培训管道中进行了其他修改。</title>
      <link>https://www.reddit.com/r/programming/comments/1mfmxas/p_implemented_the_research_paper_memorizing/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/underable-ad3290     [link]   ＆＃32;   [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfmxas/p_implemented_the_research_paper_memorizing/</guid>
      <pubDate>Sat, 02 Aug 2025 10:05:58 GMT</pubDate>
    </item>
    <item>
      <title>SEED7：我计划使用数十年的编程语言</title>
      <link>https://www.reddit.com/r/programming/comments/1mfldk0/seed7_a_programming_language_i_plan_to_work_on/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  种子7基于我的文凭和博士论文中有关可扩展的编程语言的想法（1984和1986）。 1989年，开发始于口译员，并于2005年作为开源发行。从那时起，它会定期进行改进。  seed7大约可读性，性能 and 内存安全。有一个自动内存管理，但是没有垃圾收集过程，可以中断正常处理。 模板 和  seed7是扩展性编程语言。 语句的语法和语义整个语言是在图书馆中定义的“ seed7_05.s7i”。您可以扩展语言语法上和语义上（ 种子7检查 Integer溢出。您要么获得正确的结果，要么 vellflow_error 已提高。与许多基于JVM的语言不同，SEED7提前编译到机器代码（Graal提前工作，但在反射方面挣扎）。与许多系统语言不同（Rust）不同，种子7是内存安全语言。 源代码为 github 。可以通过 make7 ：a make Utility。 href =“ https://seed7.net/scrshots/pv7.htm”&gt; pv7 ：BMP，GIF，ICO，ICO，JPEG，JPEG，PGM，PGM，PGM，PNG，PNG，PPM，PPM和TIFF FILES的图片查看器href =“ https://seed7.net/scrshots/tar7.htm”&gt; tar7 ：tar归档实用程序。   comanche ：一个用于静态HTML页面和CGI程序的简单Web服务器。 href =“ https://seed7.net/scrshots/index.htm”&gt;此处，并且有一个 embo page      带有seed7程序，可以在browser7中执行。这些程序已被编译为JavaScript/WebAssembly。 href =“ https://seed7.net/libraries/tga.htm”&gt; tga 图像，添加了文档和改进的代码质量。 请让我知道您的想法，并考虑将项目主演 &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/thomasmertes       [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfldk0/seed7_a_programming_language_i_plan_to_work_on/</guid>
      <pubDate>Sat, 02 Aug 2025 08:21:37 GMT</pubDate>
    </item>
    <item>
      <title>让我们做游戏吧！ 295：充电</title>
      <link>https://www.reddit.com/r/programming/comments/1mfk87i/lets_make_a_game_295_charging/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/apeloverage      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mfk87i/lets_make_a_game_295_charging/</guid>
      <pubDate>Sat, 02 Aug 2025 07:07:22 GMT</pubDate>
    </item>
    </channel>
</rss>