<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Thu, 16 Oct 2025 06:24:28 GMT</lastBuildDate>
    <item>
      <title>哎呀！这是一个内核堆栈释放后使用：利用 NVIDIA 的 GPU Linux 驱动程序</title>
      <link>https://www.reddit.com/r/programming/comments/1o7y5k7/oops_its_a_kernel_stack_useafterfree_exploiting/</link>
      <description><![CDATA[ 由   提交/u/BlueGoliath  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7y5k7/oops_its_a_kernel_stack_useafterfree_exploiting/</guid>
      <pubDate>Thu, 16 Oct 2025 05:43:22 GMT</pubDate>
    </item>
    <item>
      <title>人工智能在后端开发方面比前端更好，而且还差得远</title>
      <link>https://www.reddit.com/r/programming/comments/1o7xpij/ai_is_better_at_backend_development_than_frontend/</link>
      <description><![CDATA[我最近尝试了很多 AI 编码工具，并且很明显 AI 处理后端开发的能力远远好于前端工作。后端逻辑倾向于遵循具有更清晰的输入输出结构的可预测模式，因此人工智能可以通过它进行推理，并以最少的上下文生成不错的结果。 另一方面，前端是事情崩溃的地方。人工智能可以构建基本的组件和布局，但一旦你需要真正的设计质量、复杂的状态管理或感觉精致和专业的东西，它就会陷入困境。它通常会生成看起来通用、不一致或以人类开发人员或设计师永远不会错过的微妙方式出现错误的 UI。 后端代码对于 AI 来说更容易，因为它更多地涉及结构和逻辑，而不是主观设计。但一旦代码库增长或项目涉及多种服务，即使是人工智能也开始失去轨道。它在孤立的块中表现良好，但无法在整个系统中正确推理或随着时间的推移保持架构一致。 我相信，至少现在，人工智能更像是后端助手，而不是前端构建器。很好奇是否其他人也有同样的感觉，或者您是否有过在前端密集型项目中通过人工智能获得良好结果的不同经历。   由   提交 /u/Few_Homework_8322   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7xpij/ai_is_better_at_backend_development_than_frontend/</guid>
      <pubDate>Thu, 16 Oct 2025 05:16:26 GMT</pubDate>
    </item>
    <item>
      <title>分享一个设计模式思想：Reflective Delegate Pattern</title>
      <link>https://www.reddit.com/r/programming/comments/1o7wdlp/sharing_a_design_pattern_idea_reflective_delegate/</link>
      <description><![CDATA[]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7wdlp/sharing_a_design_pattern_idea_reflective_delegate/</guid>
      <pubDate>Thu, 16 Oct 2025 04:01:00 GMT</pubDate>
    </item>
    <item>
      <title>HiCode 开发者兴趣</title>
      <link>https://www.reddit.com/r/programming/comments/1o7w9e1/hicode_developer_interest/</link>
      <description><![CDATA[正在使用 HiCode，如果您是开发人员，请查看一下。    由   提交/u/Common-Agent-9902   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7w9e1/hicode_developer_interest/</guid>
      <pubDate>Thu, 16 Oct 2025 03:54:50 GMT</pubDate>
    </item>
    <item>
      <title>Node.js v25.0.0（当前）</title>
      <link>https://www.reddit.com/r/programming/comments/1o7w4fk/nodejs_v2500_current/</link>
      <description><![CDATA[ 由   提交/u/feross  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7w4fk/nodejs_v2500_current/</guid>
      <pubDate>Thu, 16 Oct 2025 03:47:32 GMT</pubDate>
    </item>
    <item>
      <title>为什么大多数应用程序应该作为单体应用开始</title>
      <link>https://www.reddit.com/r/programming/comments/1o7uk9h/why_most_apps_should_start_as_monoliths/</link>
      <description><![CDATA[ 由   提交/u/South-Reception-1251   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7uk9h/why_most_apps_should_start_as_monoliths/</guid>
      <pubDate>Thu, 16 Oct 2025 02:27:55 GMT</pubDate>
    </item>
    <item>
      <title>荒谬的SQL</title>
      <link>https://www.reddit.com/r/programming/comments/1o7tjz0/absurdersql/</link>
      <description><![CDATA[AbsurderSQL：让 Web 上的 SQLite 更进一步 如果 Web 上的 SQLite 更加荒谬怎么办？ 不久前，James Long absurd-sql 令人大吃一惊——这是一种疯狂的黑客行为，它使用 IndexedDB 作为虚拟文件系统，使 SQLite 在浏览器中持久存在。它证明您实际上可以在网络上运行真实数据库。 但它有一个巨大的缺陷：您的数据被卡住了。一旦进入 IndexedDB，就没有导出、导入、备份——没有出路。 所以我构建了 AbsurderSQL - 一个彻底的 Rust + WebAssembly 重新实现，可以完全解决这个问题。它是荒谬的 SQL，但更荒谬。 它用 Rust 编写，使用自定义 VFS，将 IndexedDB 视为具有 4KB 块、智能缓存和可选可观察性的磁盘。它在浏览器内和本机运行。你的数据呢？ 100% 可移植。 为什么构建它 我将旧版 VBA 应用程序现代化为 Next.js SPA，但有一个限制：没有服务器端持久性。它必须完全离线。 IndexedDB 是唯一的选择，但它绝不是关系型的。 然后我发现了absurd-sql。它让我完成了 80%，但最后 20% 涉及痛苦的锁定和可移植性问题。这种挫败感导致了这次重写。 您的数据，无处不在。 AbsurderSQL 允许您从标准 SQLite 文件导出和导入，而不是专有的 blob。 从 &#39;@npiesco/absurder-sql&#39; 导入 init, { Database };等待初始化（）； const db = 等待 Database.newDatabase(&#39;myapp.db&#39;); wait db.execute(&quot;创建表用户(id INTEGER PRIMARY KEY, name TEXT)&quot;); wait db.execute(“INSERT INTO users VALUES (1, &#39;Alice&#39;)”); // 导出真实的 SQLite 文件 const bytes = wait db.exportToFile();  该文件适用于任何地方 - CLI、Python、Rust、DB 浏览器等。 您可以在任何浏览器中备份、提交、共享或重新导入它。 双模式架构 一个代码库，两种模式。  浏览器 (WASM)： IndexedDB 支持的 SQLite 数据库，具有缓存、选项卡协调和导出/导入功能。 本机 (Rust)： 相同的 API，但使用文件系统，方便服务器或 CLI 实用程序。  非常适合偶尔同步到后端的离线优先应用程序。 有效的多选项卡协调 AbsurderSQL 附带内置的领导者选举和写入协调：  一个领导者选项卡处理写入 追随者队列写入领导者 BroadcastChannel 通知所有选项卡数据更改，无数据争用，无损坏。  性能 IndexedDB 确实很慢，但是缓存、批处理和异步 Rust I/O 会产生巨大的差异：   操作 absurd-sql AbsurderSQL    100k 行读取 ~2.5s ~0.8s（冷）/~0.05s（热）   10k 行写入 ~3.2s ~0.6s   从头开始生锈 absurd-sql 修补了 C++/JS 内部； AbsurderSQL 是惯用的 Rust：  安全快速的异步 I/O（无 Asyncify 膨胀） 完整的 ACID 事务 块级 CRC 校验和 可选的 Prometheus/OpenTelemetry 支持（约 660 KB 压缩的 WASM 构建）  下一步是什么  移动支持（为 iOS/Android 编译的相同 Rust 核心） WASM 组件模型集成 用于未来浏览器 API 的可插拔存储后端  GitHub： npiesco/absurder-sql 许可证： AGPL-3.0 James Long 展示了浏览器中的 SQLite 是可能的。 AbsurderSQL 展示了它可以是生产级。   由   提交/u/Standard-Ad9181   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7tjz0/absurdersql/</guid>
      <pubDate>Thu, 16 Oct 2025 01:39:39 GMT</pubDate>
    </item>
    <item>
      <title>我是如何差点被“求职面试”黑客攻击的</title>
      <link>https://www.reddit.com/r/programming/comments/1o7t10r/how_i_almost_got_hacked_by_a_job_interview/</link>
      <description><![CDATA[ 由   提交 /u/rchaudhary   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7t10r/how_i_almost_got_hacked_by_a_job_interview/</guid>
      <pubDate>Thu, 16 Oct 2025 01:15:06 GMT</pubDate>
    </item>
    <item>
      <title>PyTorch 2.9 发布博客</title>
      <link>https://www.reddit.com/r/programming/comments/1o7pi1a/pytorch_29_release_blog/</link>
      <description><![CDATA[ 由   提交 /u/mttd   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7pi1a/pytorch_29_release_blog/</guid>
      <pubDate>Wed, 15 Oct 2025 22:39:14 GMT</pubDate>
    </item>
    <item>
      <title>通过简单的可视化学习二进制系统 – 编程初学者系列</title>
      <link>https://www.reddit.com/r/programming/comments/1o7o783/aprenda_sistema_binário_com_visualização_simples/</link>
      <description><![CDATA[【教育系列】简单可视化学习数系——从二进制开始 大家好！ 👨‍🏫 我是 Wanderlei Silva do Carmo，教育计算领域的专家，我正在制作一系列视频，帮助初学者理解数字系统，从二进制系统（基数为 2）开始。 我使用简单的视觉表示（如表示位的彩色球）来解释以下概念：  位、字节和位置 值 二进制到十进制的转换 二进制在计算中的应用  非常适合那些刚刚开始编程或想强化计算逻辑基础的人。 📺观看第一个视频：[视频链接] 💬非常欢迎您提出意见和建议！   由   提交/u/w3aewander   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7o783/aprenda_sistema_binário_com_visualização_simples/</guid>
      <pubDate>Wed, 15 Oct 2025 21:44:32 GMT</pubDate>
    </item>
    <item>
      <title>更多代码≠更好代码：Claude Haiku 4.5 多编写了 62% 的代码，但得分降低了 16%（WebSocket 重构分析）</title>
      <link>https://www.reddit.com/r/programming/comments/1o7o6ek/more_code_better_code_claude_haiku_45_wrote_62/</link>
      <description><![CDATA[ 由   提交/u/CodeLensAI   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7o6ek/more_code_better_code_claude_haiku_45_wrote_62/</guid>
      <pubDate>Wed, 15 Oct 2025 21:43:38 GMT</pubDate>
    </item>
    <item>
      <title>由于 GenAI，技术主管正在成为技术领域最重要的角色之一</title>
      <link>https://www.reddit.com/r/programming/comments/1o7ndf2/tech_lead_is_becoming_one_of_the_most_important/</link>
      <description><![CDATA[ 由   提交/u/gregorojstersek   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7ndf2/tech_lead_is_becoming_one_of_the_most_important/</guid>
      <pubDate>Wed, 15 Oct 2025 21:11:51 GMT</pubDate>
    </item>
    <item>
      <title>解开 Cloudflare Workers CPU 性能基准</title>
      <link>https://www.reddit.com/r/programming/comments/1o7nads/unpacking_cloudflare_workers_cpu_performance/</link>
      <description><![CDATA[Cloudflare 解决了基准测试，显示 Workers 在 CPU 密集型任务中比 Vercel 慢。他们将差距追溯到 V8 调优、调度以及库和适配器的低效率。修复包括更好的隔离调度、内存调整以及对 OpenNext 和 JSON.parse 的优化。他们还推动了 V8 和 Node.js 的上游改进。因此，Workers 现在在大多数测试中的表现与 Vercel 相当，在其余测试中表现更接近，而 Cloudflare 则继续改进性能。   由   提交 /u/Happy_Junket_9540   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7nads/unpacking_cloudflare_workers_cpu_performance/</guid>
      <pubDate>Wed, 15 Oct 2025 21:08:28 GMT</pubDate>
    </item>
    <item>
      <title>我使用 Stream Deck 在 Visual Studio 中自动化了我的 C# 工作流程，它改变了游戏规则</title>
      <link>https://www.reddit.com/r/programming/comments/1o7f7ar/i_automated_my_c_workflow_in_visual_studio_with_a/</link>
      <description><![CDATA[嘿，C# 开发人员朋友们， 我厌倦了记住复杂的 Visual Studio 键盘快捷键和不断管理我的工作区，所以我决定看看是否可以构建一个更加物理化、简化的工作流程。我最终使用 Elgato Stream Deck 创建了一个完整的生产力系统，其结果对于我的专注力和编码速度而言令人难以置信。 我想分享它，因为这些原理可以适用于任何 C# 项目，无论您是在 Web、桌面还是游戏上工作。 我为 C# 工作流程设置的一些关键自动化包括：  一键 VS 命令：不再需要 Ctrl+K、Ctrl+D！我有一个物理按钮来格式化整个文档。我还提供了无需使用鼠标即可轻松左右移动文档选项卡的按钮。 改变游戏规则的 VS 扩展：在视频中，我展示了一个名为 Supercharger 的免费扩展，它可以让您对整个方法体进行颜色编码。这对于快速导航和理解大型、复杂的课程来说是一个救星。 集成焦点工具：我还内置了一个番茄计时器来帮助我坚持“深度工作”。在编码期间安排并排除干扰。  我制作了一个详细的视频，介绍整个设置，展示如何将 Stream Deck 连接到 Visual Studio 并演示 Supercharger 扩展。   由   提交/u/larex39  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7f7ar/i_automated_my_c_workflow_in_visual_studio_with_a/</guid>
      <pubDate>Wed, 15 Oct 2025 16:07:03 GMT</pubDate>
    </item>
    <item>
      <title>从零到您的第一个 eBPF 程序（实践教程）</title>
      <link>https://www.reddit.com/r/programming/comments/1o7ekau/from_zero_to_your_first_ebpf_program_handson/</link>
      <description><![CDATA[ 由   提交/u/iximiuz  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o7ekau/from_zero_to_your_first_ebpf_program_handson/</guid>
      <pubDate>Wed, 15 Oct 2025 15:43:33 GMT</pubDate>
    </item>
    </channel>
</rss>