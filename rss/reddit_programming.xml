<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Sat, 16 Aug 2025 15:15:34 GMT</lastBuildDate>
    <item>
      <title>| [2] [2，Q2，Q3]（3）|在这里，我正在考虑强调和实践的可能性，以及大胆的/草书/罢工。丰富的文字。任何1都想得到富有的文字？ （来吧</title>
      <link>https://www.reddit.com/r/programming/comments/1mry2mc/22q2q33_here_i_am_thinking_about_the/</link>
      <description><![CDATA[]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mry2mc/22q2q33_here_i_am_thinking_about_the/</guid>
      <pubDate>Sat, 16 Aug 2025 15:14:13 GMT</pubDate>
    </item>
    <item>
      <title>如何在失败期间保持服务运行？</title>
      <link>https://www.reddit.com/r/programming/comments/1mrxkt0/how_to_keep_services_running_during_failures/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/scalableThreadRead      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrxkt0/how_to_keep_services_running_during_failures/</guid>
      <pubDate>Sat, 16 Aug 2025 14:56:22 GMT</pubDate>
    </item>
    <item>
      <title>日本网页设计的特殊情况</title>
      <link>https://www.reddit.com/r/programming/comments/1mrxjog/the_peculiar_case_of_japanese_web_design/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/witty-play9499       [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrxjog/the_peculiar_case_of_japanese_web_design/</guid>
      <pubDate>Sat, 16 Aug 2025 14:55:11 GMT</pubDate>
    </item>
    <item>
      <title>LLMS已经包含所有应得的答案；他们只是缺乏找出大多数过程的过程 - 我建立了一个以倒退启发的提示工具，该工具以tot为基础，从中挖掘出深层的含义</title>
      <link>https://www.reddit.com/r/programming/comments/1mrubj9/llms_already_contain_all_posible_answers_they/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  大型实验室正在用“深思想”解决此问题方法，从本质上讲，他们的巨型模型更多的时间和资源可以在内部解决问题。这很好，但是感觉好像注定要锁定在公司API后面。我想探索是否可以在较小的机器上实现类似的效果。因此，我构建了一个名为“代理网络（NOA）”的项目，以尝试创建这些模型缺少的过程。 核心想法是停止将LLM当作答案机，并开始将其用作较大推理引擎中的齿轮。 NOA模拟了一个AI代理的社会，该社会合作从LLM自己的潜在知识中挖掘解决方案。 您可以找到完整的 readme.md“&gt; readme.md”&gt; readme.md  href=&quot;https://github.com/andres-ulloa-de-la-torre/NoA/tree/main&quot;&gt;github It works through a cycle of thinking and refinement, inspired by how a team of humans might work: The Forward Pass (Conceptualization): Instead of one agent, NoA builds a whole network of them in layers.第一层从不同的角度解决了问题。下一层采用其输出，合成它们，并构建更专业的视角。这会创建问题空间的深度，多维视图，所有这些视图均来自相同的基本模型。 反射通行证（改进）：这是采矿的关键。网络的最终合成答案由评论代理人分析。该批评是一个错误信号，该信号通过代理网络向后传播。每个代理都看到反馈，弄清楚其在最终输出的缺点中的作用，并重写自己的说明以在下一轮中变得更好。这是网络学习的缓慢，迭代的过程，可以更好地思考集体。通过多个周期（时代），网络可以完善其方法，更深入地挖掘并连接单一提示永远不会浮出水面的想法。它不是在学习新事实；它正在学习如何通过已经拥有的事实来推理。溶液被开采，而不仅仅是检索。该项目仍然是一个研究原型，但这是使深入思考民主化的切实尝试。我真正地相信下一个突破不仅是更大的模型，而且可以使用它们的更好的过程。我很想听听大家对这种方法的看法。 感谢您阅读  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/usary_exam_3620        [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrubj9/llms_already_contain_all_posible_answers_they/</guid>
      <pubDate>Sat, 16 Aug 2025 12:48:36 GMT</pubDate>
    </item>
    <item>
      <title>找到AI实体</title>
      <link>https://www.reddit.com/r/programming/comments/1mrtkoz/find_ai_entity/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  请部署  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/akey_dragonfly366     [link]   ＆＃32;   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrtkoz/find_ai_entity/</guid>
      <pubDate>Sat, 16 Aug 2025 12:15:53 GMT</pubDate>
    </item>
    <item>
      <title>用氛围编码与订阅疲劳作斗争</title>
      <link>https://www.reddit.com/r/programming/comments/1mrtifs/fighting_subscription_fatigue_with_vibecoding/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/missics      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrtifs/fighting_subscription_fatigue_with_vibecoding/</guid>
      <pubDate>Sat, 16 Aug 2025 12:12:57 GMT</pubDate>
    </item>
    <item>
      <title>塞巴斯蒂安·拉格（Sebastian Lague）：射线追踪的玻璃和苛刻</title>
      <link>https://www.reddit.com/r/programming/comments/1mrtg4o/sebastian_lague_raytraced_glass_and_caustics/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/pink401k      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrtg4o/sebastian_lague_raytraced_glass_and_caustics/</guid>
      <pubDate>Sat, 16 Aug 2025 12:10:08 GMT</pubDate>
    </item>
    <item>
      <title>我的第一个生锈箱</title>
      <link>https://www.reddit.com/r/programming/comments/1mrsxwv/my_first_rust_crate/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/rogerara       [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrsxwv/my_first_rust_crate/</guid>
      <pubDate>Sat, 16 Aug 2025 11:46:52 GMT</pubDate>
    </item>
    <item>
      <title>新的代码基础工作流程的想法</title>
      <link>https://www.reddit.com/r/programming/comments/1mrsq7s/idea_for_a_new_codegen_workflow/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/david01354       [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrsq7s/idea_for_a_new_codegen_workflow/</guid>
      <pubDate>Sat, 16 Aug 2025 11:36:25 GMT</pubDate>
    </item>
    <item>
      <title>Hello Mac OS X Tiger（2022）</title>
      <link>https://www.reddit.com/r/programming/comments/1mrqtyl/hello_mac_os_x_tiger_2022/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/nsredditshitposter       [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrqtyl/hello_mac_os_x_tiger_2022/</guid>
      <pubDate>Sat, 16 Aug 2025 09:59:30 GMT</pubDate>
    </item>
    <item>
      <title>使用双子座 + Ollama 3</title>
      <link>https://www.reddit.com/r/programming/comments/1mrqlc0/experimenting_with_dyad_selfhosted_coding/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  我最近测试了 dyad ，是一个自托管的开源编码助手。它可以连接到诸如Google gemini之类的外部模型，但它还通过本地推理通过 ollama 3 。 我记录了整个设置（linux），然后通过一系列的编程挑战来看到它的实用范围是如何实现的： Kahoot-style clone and even rebuilding one of my own projects (an animated 3D map in Three.js)  For comparison, I ran Dyad both with Gemini (cloud) and Ollama 3 locally on my PC.本地运行较慢，更有限，但仍然能够完成某些任务。 好奇是否有人尝试过自托管编码助手。您是否发现它们对于真实的项目或在此阶段更为新颖？  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/onsealddemor       [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrqlc0/experimenting_with_dyad_selfhosted_coding/</guid>
      <pubDate>Sat, 16 Aug 2025 09:46:11 GMT</pubDate>
    </item>
    <item>
      <title>用三分和反应构建AI驱动的字符</title>
      <link>https://www.reddit.com/r/programming/comments/1mrpud3/building_aipowered_characters_with_threejs_and/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/santosh_arron      [commist]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrpud3/building_aipowered_characters_with_threejs_and/</guid>
      <pubDate>Sat, 16 Aug 2025 09:04:07 GMT</pubDate>
    </item>
    <item>
      <title>Dropstone-第一代自学AI开发平台</title>
      <link>https://www.reddit.com/r/programming/comments/1mrpsiv/dropstone_first_generational_selflearning_ai/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/santosh_arron      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrpsiv/dropstone_first_generational_selflearning_ai/</guid>
      <pubDate>Sat, 16 Aug 2025 09:01:11 GMT</pubDate>
    </item>
    <item>
      <title>Typechecker动物园</title>
      <link>https://www.reddit.com/r/programming/comments/1mrp42o/typechecker_zoo/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/local_citron_5895       [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrp42o/typechecker_zoo/</guid>
      <pubDate>Sat, 16 Aug 2025 08:22:48 GMT</pubDate>
    </item>
    <item>
      <title>作为专业开发人员，我实际上喜欢使用基于节点的视觉编程系统</title>
      <link>https://www.reddit.com/r/programming/comments/1mrp1up/as_a_professional_developer_i_actually_like/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  作为序言，我是我的职业的全职软件开发人员；我已经编程已有17年了，而IVE的职业能力为8年。我在各种公司中担任过各种职位，有些是高级或主要的技术领导者，我对生产代码负有很大的责任。因此，我知道我在说什么。 我所有的专业编码都是基于文本的，几乎所有个人项目也（💜RUST）。如果您想确认。 ，当我有时“强迫”时，可以检查我的github。要使用基于节点的编程系统（想想Comfyui，UE蓝图，Unity ShaderGraph，Resonite ProtoFlux），我实际上并没有觉得这么冒犯。实际上，我通常喜欢它。当然，对于习惯于基于文本的编程的人来说，学习曲线有点陡峭，它涉及很多使用鼠标（我知道我的一些VIM用户朋友会非常沮丧），但是一旦您掌握了鼠标，您就可以在基于文本的编辑器中写完整的时间，或者基本上几乎完全具有完整的程序。  大多数基于节点的系统都是纯粹的表达式（舒适，阴影），这是我认为基于节点的编程的地方。它基本上是一个编码完全图灵完整的，完全纯净的功能代码的系统。当然，如果涉及操纵状态，并且执行循环有时会有些限制。但是对于某些应用，这完全是足够的，并且是超级直观的IMO。  某些系统确实涉及某种形式的执行顺序（蓝图，ProtoFlux）。尽管这确实带来了基于节点的编程“行”。命令＆amp;完整的文本编程语言的基于状态的功能，我觉得在您可能想做的事情方面，它有时可能有些指定。我不认为这是基于节点的编程的根本失败，但实际上，我认为这是一个问题，随着时间的流逝，由于不同的系统产生了不同的解决方案。 我曾经曾经曾经使用过不同的解决方案。没有适当的语言完成。但老实说，我的钱？基于节点的编程有点糟糕。我喜欢它。尤其是在功能范围的范围中，其范围是很好的和直观的。在许多情况下，能够在整个第二维度组织您的代码实际上是精神清晰的（对于ProtoFlux的第三位），并且能够“可视化”。该程序作为流程图直接在窗口中流动，对于精神流利而言是惊人的。更不用说，您几乎不必担心语法错误。 我认为，视觉编程会因早期的语言流行而变得不良说唱，并且由于所有“低/not code”在2010年代后期很受欢迎的应用程序开发平台（所有人都很烂，相信我，我不得不与其中一些合作）。但是，基于节点的编程诚实和真实地似乎是软件开发的可行且有希望的途径。我几乎会危险地说，一旦有效的国家处理和命令执行的有效语法变得更加巩固，最终可能会在很大程度上取代文本编程。   &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/dynabeast       [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1mrp1up/as_a_professional_developer_i_actually_like/</guid>
      <pubDate>Sat, 16 Aug 2025 08:19:26 GMT</pubDate>
    </item>
    </channel>
</rss>