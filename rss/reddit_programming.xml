<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Mon, 15 Dec 2025 01:20:25 GMT</lastBuildDate>
    <item>
      <title>xreferee：跨存储库强制执行交叉引用</title>
      <link>https://www.reddit.com/r/programming/comments/1pmu4vs/xreferee_enforce_cross_references_across_a/</link>
      <description><![CDATA[从 README 中复制：  验证整个 git 存储库中的交叉引用。 链接代码库中的两个不同位置通常很有用，并且可能并不总是可以通过导入共同的事实来源来强制执行它。一些示例：  在两种不同语言的文件之间保持两个常量同步 将实现链接到记录设计的 Markdown 文件或注释   xreferee 验证 @(ref:foo) 形式的引用在存储库。 这在以前的公司非常有用，并且认为它对于开源很有用。   由   提交/u/brandonchinn178  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmu4vs/xreferee_enforce_cross_references_across_a/</guid>
      <pubDate>Mon, 15 Dec 2025 00:53:12 GMT</pubDate>
    </item>
    <item>
      <title>作为开发者，哪些功能会让您真正使用社交平台？</title>
      <link>https://www.reddit.com/r/programming/comments/1pmtwff/what_features_would_make_you_actually_use_a/</link>
      <description><![CDATA[我一直在思考为什么开发者默认使用 X 或者完全避免社交平台。明显的痛点： - 共享代码意味着屏幕截图或外部链接 - 没有语法突出显示 - 字符限制扼杀了技术讨论 我正在研究解决这个问题的方法，但很好奇还有什么对你来说很重要。原生降价？ GitHub 集成？还有别的吗？   由   提交/u/Smart-Tourist817   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmtwff/what_features_would_make_you_actually_use_a/</guid>
      <pubDate>Mon, 15 Dec 2025 00:42:06 GMT</pubDate>
    </item>
    <item>
      <title>我在付款中杀死了一名工人来测试“仅一次”执行</title>
      <link>https://www.reddit.com/r/programming/comments/1pmtlez/i_killed_a_worker_midpayment_to_test_exactlyonce/</link>
      <description><![CDATA[分布式系统通常声称“恰好一次”执行。在实践中，这通常被实现为至少一次传递+重试+幂等键。 这适用于确定性代码。它会因不可逆转的副作用（AI 代理、LLM 调用、物理基础设施）而崩溃。 我想看看如果工作人员在付款之后但确认完成之前崩溃，实际会发生什么。因此，我构建了一个具有以下规则的最小执行内核：基础设施永远不会重播用户代码。 内核使用：  租约（隔离令牌/纪元） 恢复崩溃任务的协调器 严格的状态转换（无静默重试）  我运行了这个实验：  一名工作人员领取了一项处理 99.99 美元付款的任务 该工作人员记录了付款（不可逆的副作用） 我 在将完成发送到数据库之前杀死 -9 工作人员 租约到期，协调器检测到僵尸任务 一名新工作人员使用新的任务领取该任务fencing 令牌 新工作人员在分类帐中看到之前的尝试（通过应用程序逻辑）并中止 任务安全失败  结果： 恰好记录了一笔付款。钱没有重复。 大多数工作流引擎（Temporal、Airflow、Celery）默认在崩溃时重试任务逻辑。这假设您的代码是幂等的。  AI 代理不是幂等的。 LLM 生成不是幂等的。 支付 API（没有密钥）不是幂等的。  我在这里开源了内核和混沌演示。重点不是采用。重点是让重放再次变得不安全。 https://github.com/abokhalill/pulse   由   提交/u/AdministrativeAsk305   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmtlez/i_killed_a_worker_midpayment_to_test_exactlyonce/</guid>
      <pubDate>Mon, 15 Dec 2025 00:27:30 GMT</pubDate>
    </item>
    <item>
      <title>构建了一个能够自主生成完整应用程序的人工智能系统——架构分解和经验教训</title>
      <link>https://www.reddit.com/r/programming/comments/1pmtf3a/built_an_ai_system_that_generates_complete/</link>
      <description><![CDATA[我花了 4 个月的时间构建 APEX - 一个具有 430 种功能的多代理 AI 系统，可以从自然语言生成生产就绪的全栈应用程序。 **架构：** APEX 在 10 个自治阶段协调 6 个专门的子代理： - ATLAS（协调员）- 计划任务、委派工作 - CATALYST（构建器）- 生成代码文件 - CIPHER（分析器）- 读取日志，了解故障 - AEGIS（验证器）- 测试和验证 - REMEDY（修复器）- 修补错误，自我修复 - VERDICT（评估器）- 评分质量，做出决策 **技术挑战已解决：** 最难的部分是跨堆栈的导入路径解析。生成的文件需要相互导入，并且在前端/后端/数据库之间获取正确的路径并非易事。 解决方案：第 52 阶段的依赖关系图计算确定生成顺序并确保所有导入正确解析。 **真实性能：** 输入：“使用看板构建任务管理 SaaS” 输出（2 秒后）： - 3 个 React 组件（KanbanBoard、TaskCard、TaskList） - 具有 CORS 和路由的 FastAPI 后端 - 具有 3 个规范化表的 PostgreSQL 模式 - 完整的架构蓝图 **代码质量：** 生成的 FastAPI 服务器包括正确的 CORS 配置、Pydantic 模型、路由组织和 Uvicorn 生产设置。不是玩具代码 - 实际的生产脚手架。 **我期望的问题：** “这是真实的还是蒸气软件？” 100% 真实。工作演示。可以实时生成应用程序。 “这会取代开发人员吗？” 不会。是他们的 100 倍。消除样板文件，让开发人员解放出来进行创造性工作。 **技术细节：** 基于任务复杂性的多 LLM 路由（Gemini → Claude → GPT-4） 自我修复错误检测和纠正 基于 Firestore 的共享智能层 基于阶段的自主执行 更多信息：https://justiceapexllc.com/engine 很高兴回答有关架构、LLM 路由或自主编排的问题。   由   提交 /u/TTVJusticeRolls   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmtf3a/built_an_ai_system_that_generates_complete/</guid>
      <pubDate>Mon, 15 Dec 2025 00:18:59 GMT</pubDate>
    </item>
    <item>
      <title>LLM 代理不断循环并破坏 UI 状态 - 我通过使执行具有确定性来修复它</title>
      <link>https://www.reddit.com/r/programming/comments/1pmriw6/llm_agents_kept_looping_and_breaking_ui_state_i/</link>
      <description><![CDATA[我是 SaaS 产品的前端工程师。在某些时候，我注意到大多数 SaaS UI 都不是一个开放的世界 - 它们主要是将 BFF DTO 投射到一小组重复出现的模式中：表单、卡片、表格、仪表板、过滤器。 我正在尝试让 LLM 驱动此 UI 的部分内容。我从通常的代理循环开始：模型推理、改变 UI 状态、检查结果并重复。它在技术上可行，但很脆弱。简单的任务需要多个循环，状态以我无法重现的方式漂移，调试主要归结为阅读日志和猜测。 改变的事情是使 SaaS 结构变得明确并缩小模型的角色。我没有让 LLM 直接改变状态，而是让它通过 UI 状态的类型化快照发出单个经过验证的意图。然后，确定性运行时应用效果、运行验证并更新快照。 这完全消除了代理循环。状态转换变得可重播，调试不再是猜测，成本下降到足以使小型模型真正可用。当出现问题时，我可以准确地看到转换失败的位置。 这不是一个新的代理框架或人工智能理念。它只是将 SaaS UI 视为现有的结构化系统，并让模型在该结构上运行，而不是自由形式的 UI 突变。 演示和代码： https://taskflow.manifesto-ai.dev https://github.com/manifesto-ai/taskflow   由   提交/u/TraditionalListen994   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmriw6/llm_agents_kept_looping_and_breaking_ui_state_i/</guid>
      <pubDate>Sun, 14 Dec 2025 22:52:50 GMT</pubDate>
    </item>
    <item>
      <title>我在浏览器中构建了一个实时 ASCII 相机（60 FPS、Canvas、TypeScript）</title>
      <link>https://www.reddit.com/r/programming/comments/1pmnk5o/i_built_a_realtime_ascii_camera_in_the_browser_60/</link>
      <description><![CDATA[ 由   提交/u/Aroy666  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmnk5o/i_built_a_realtime_ascii_camera_in_the_browser_60/</guid>
      <pubDate>Sun, 14 Dec 2025 20:06:07 GMT</pubDate>
    </item>
    <item>
      <title>我创建了一个实时匿名聊天系统并遇到了审核挑战</title>
      <link>https://www.reddit.com/r/programming/comments/1pmn8ge/i_created_a_real_time_anonymous_chat_system_and/</link>
      <description><![CDATA[ 由   提交/u/eren_rndm   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmn8ge/i_created_a_real_time_anonymous_chat_system_and/</guid>
      <pubDate>Sun, 14 Dec 2025 19:52:58 GMT</pubDate>
    </item>
    <item>
      <title>实施崩溃安全预写日志的经验教训</title>
      <link>https://www.reddit.com/r/programming/comments/1pmkzy8/lessons_from_implementing_a_crashsafe_writeahead/</link>
      <description><![CDATA[我写这篇文章是为了记录为什么 WAL 正确性需要多层（对齐、尾部金丝雀、CRC、目录 fsync），基于我在构建一层时遇到的失败。   由   提交/u/ankur-anand  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmkzy8/lessons_from_implementing_a_crashsafe_writeahead/</guid>
      <pubDate>Sun, 14 Dec 2025 18:22:13 GMT</pubDate>
    </item>
    <item>
      <title>操作系统的微小限制导致程序以令人困惑的方式失败</title>
      <link>https://www.reddit.com/r/programming/comments/1pmjpmj/a_tiny_os_limit_that_makes_programs_fail_in/</link>
      <description><![CDATA[这与框架或语言无关。 这是关于影响 Java、Node、Python、Docker 以及几乎所有内容的操作系统级别限制。 如果您曾经在负载下追踪过“随机”故障，这可能会解释其中的一些故障。 链接： https://blog.stackademic.com/the-one-setting-in-ubuntu-that-quietly-breaks-your-apps-ulimit-n-f458ab437b7d?sk=4e540d4a7b6d16eb826f469de8b8f9ad   由   提交/u/sshetty03  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmjpmj/a_tiny_os_limit_that_makes_programs_fail_in/</guid>
      <pubDate>Sun, 14 Dec 2025 17:29:58 GMT</pubDate>
    </item>
    <item>
      <title>人工智能和自动化的讽刺 - 第 2 部分</title>
      <link>https://www.reddit.com/r/programming/comments/1pmjpbh/ai_and_the_ironies_of_automation_part_2/</link>
      <description><![CDATA[关于自动化的限制和权衡的非常有趣且发人深省的文章：  因为这些基于人工智能的代理有时会产生错误，所以人类（在我们的示例中是软件开发人员）需要监督人工智能代理团队，并最好在人工智能代理做他们不应该做的事情之前进行干预。因此，人工智能代理通常会制定一个他们打算首先做什么的计划（这作为副作用也增加了他们不会迷失方向的可能性）。然后，人类验证该计划并在正确的情况下批准该计划，然后人工智能代理执行该计划。如果计划不正确，人类会拒绝它，并将代理送回重新计划，提供有关需要更改的信息。  这些代理可能会随着时间的推移而变得更好，但它们将持续需要人类监督 - 总是存在出错的可能性。这给我们带来了问题：  我们如何训练人类操作员能够在异常的、通常难以解决的情况下熟练地进行干预（如果理论上不需要经常需要技能，因为外包给人工智能）？ 我们如何训练人类操作员，使他们的技能随着时间的推移保持敏锐，并且他们仍然能够快速、机智地解决异常情况（同样，如果理论上不需要经常需要技能，因为外包给人工智能）？   也许最后的讽刺是，它是最成功的自动化系统，很少需要人工干预，这可能需要在人类操作员培训方面进行最大的投资。    由   提交/u/BinaryIgor  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmjpbh/ai_and_the_ironies_of_automation_part_2/</guid>
      <pubDate>Sun, 14 Dec 2025 17:29:35 GMT</pubDate>
    </item>
    <item>
      <title>写代码与写散文</title>
      <link>https://www.reddit.com/r/programming/comments/1pmid3g/writing_code_vs_writing_prose/</link>
      <description><![CDATA[ 由   提交/u/bnuredini  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmid3g/writing_code_vs_writing_prose/</guid>
      <pubDate>Sun, 14 Dec 2025 16:36:41 GMT</pubDate>
    </item>
    <item>
      <title>反对微服务的案例</title>
      <link>https://www.reddit.com/r/programming/comments/1pmhvsd/the_case_against_microservices/</link>
      <description><![CDATA[我想与大家分享我多年来积累的经验。顺便说一句，我做了分布式系统，所以希望我的经验可以帮助人们进行技术选择。   由   提交/u/01x-engineer   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmhvsd/the_case_against_microservices/</guid>
      <pubDate>Sun, 14 Dec 2025 16:17:37 GMT</pubDate>
    </item>
    <item>
      <title>如果你截断 UUID 我会截断你的手指</title>
      <link>https://www.reddit.com/r/programming/comments/1pmescz/if_you_truncate_a_uuid_i_will_truncate_your/</link>
      <description><![CDATA[ 由   提交/u/andyg_blog  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmescz/if_you_truncate_a_uuid_i_will_truncate_your/</guid>
      <pubDate>Sun, 14 Dec 2025 14:03:20 GMT</pubDate>
    </item>
    <item>
      <title>LPC 2025 - B1 馆 - 东京现场</title>
      <link>https://www.reddit.com/r/programming/comments/1pmeqp0/lpc_2025_hall_b1_live_from_tokyo/</link>
      <description><![CDATA[ 由   提交/u/BlueGoliath  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmeqp0/lpc_2025_hall_b1_live_from_tokyo/</guid>
      <pubDate>Sun, 14 Dec 2025 14:01:17 GMT</pubDate>
    </item>
    <item>
      <title>您听说过的最奇怪的编程语言！</title>
      <link>https://www.reddit.com/r/programming/comments/1pmeq58/the_strangest_programming_languages_youve_ever/</link>
      <description><![CDATA[与我们分享您听说过的最奇怪编程语言：   由   提交/u/Leading-Welcome-5847   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1pmeq58/the_strangest_programming_languages_youve_ever/</guid>
      <pubDate>Sun, 14 Dec 2025 14:00:42 GMT</pubDate>
    </item>
    </channel>
</rss>