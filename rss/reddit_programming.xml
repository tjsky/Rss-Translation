<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Mon, 13 Oct 2025 15:16:56 GMT</lastBuildDate>
    <item>
      <title>Python 3.14 的 7 个关键更新让您的编码更轻松、更快、更好</title>
      <link>https://www.reddit.com/r/programming/comments/1o5lp3s/7_key_python_314_updates_to_make_your_coding/</link>
      <description><![CDATA[ 由   提交/u/wyhjsbyb   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5lp3s/7_key_python_314_updates_to_make_your_coding/</guid>
      <pubDate>Mon, 13 Oct 2025 14:46:09 GMT</pubDate>
    </item>
    <item>
      <title>如何使用人工智能帮助完成软件工程任务</title>
      <link>https://www.reddit.com/r/programming/comments/1o5kmc5/how_to_use_ai_to_help_with_software_engineering/</link>
      <description><![CDATA[ 由   提交 /u/gregorojstersek   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5kmc5/how_to_use_ai_to_help_with_software_engineering/</guid>
      <pubDate>Mon, 13 Oct 2025 14:04:53 GMT</pubDate>
    </item>
    <item>
      <title>Chat UNcontrol - 开源自托管临时安全聊天</title>
      <link>https://www.reddit.com/r/programming/comments/1o5ka0r/chat_uncontrol_an_open_source_selfhostable/</link>
      <description><![CDATA[大家好， 随着有关聊天控制 2.0 的讨论（欧洲计划扫描私人消息，冒着隐私风险），我构建了一个简单的工具来帮助人们安全地聊天。 Chat UNcontrol 是一款 alpha 阶段的应用程序，可让您创建私人加密聊天链接。消息会自动消失，除了参与者之外没有人可以阅读它们。 由于我作为开发人员的全职工作，空闲时间有限，所以我在 AI 的帮助下开发了它。这使得这个过程变得更快更容易。 这是对聊天控制 2.0 的直接响应，旨在保护您的隐私和通信自由。 如果您想尝试它或想要演示链接，请随时与我联系！ 此处存储： https://github.com/gorecodes/chatuncontrol 很高兴收到反馈或问题！   由   提交/u/goregasm_  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5ka0r/chat_uncontrol_an_open_source_selfhostable/</guid>
      <pubDate>Mon, 13 Oct 2025 13:51:26 GMT</pubDate>
    </item>
    <item>
      <title>汇编编程是残酷的，也是美丽的，甚至可能是通往更好人工智能的道路</title>
      <link>https://www.reddit.com/r/programming/comments/1o5jq1w/programming_in_assembly_is_brutal_beautiful_and/</link>
      <description><![CDATA[ 由   提交/u/wiredmagazine  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5jq1w/programming_in_assembly_is_brutal_beautiful_and/</guid>
      <pubDate>Mon, 13 Oct 2025 13:28:29 GMT</pubDate>
    </item>
    <item>
      <title>环境变量是一个遗留的混乱：让我们深入研究它们</title>
      <link>https://www.reddit.com/r/programming/comments/1o5j78b/environment_variables_are_a_legacy_mess_lets_dive/</link>
      <description><![CDATA[ 由   提交/u/Low-Strawberry7579  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5j78b/environment_variables_are_a_legacy_mess_lets_dive/</guid>
      <pubDate>Mon, 13 Oct 2025 13:06:30 GMT</pubDate>
    </item>
    <item>
      <title>原子幂等性：精确一次执行的实用方法</title>
      <link>https://www.reddit.com/r/programming/comments/1o5huwk/atomic_idempotency_a_practical_approach_to/</link>
      <description><![CDATA[ 由   提交 /u/ymz-ncnk   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5huwk/atomic_idempotency_a_practical_approach_to/</guid>
      <pubDate>Mon, 13 Oct 2025 12:06:20 GMT</pubDate>
    </item>
    <item>
      <title>了解 Go 中的适配器设计模式：实用指南</title>
      <link>https://www.reddit.com/r/programming/comments/1o5hsqh/understanding_the_adapter_design_pattern_in_go_a/</link>
      <description><![CDATA[嘿伙计们， 我刚刚写完一篇关于 Go 中的适配器设计模式的深入博客 - 这种模式乍一看很简单，但实际上在集成遗留系统或第三方系统时可以节省您的理智。 这篇文章涵盖了从基础知识到实际代码示例的所有内容：  如何制作 不兼容的接口可以在不接触旧代码的情况下协同工作 何时实际使用适配器（何时不使用） 类适配器与对象适配器之间的区别 真实世界的示例，例如包装 JSON 记录器或支付 API 常见的反模式（例如“适配器地狱”😅） Go 特定的习惯用法： 轻量级、界面驱动且干净  如果您曾经发现自己编写丑陋的粘合代码只是为了让两个系统进行对话 - 这就是为您准备的。 🔗 阅读此处： https://medium.com/design-bootcamp/understanding-the-adapter-design-pattern-in-go-a-practical-guide-a595b256a08b 很想听听您如何处理 Go 中的遗留集成或 SDK 不匹配问题 - 您使用适配器还是进行完全重写？   由   提交/u/priyankchheda15   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5hsqh/understanding_the_adapter_design_pattern_in_go_a/</guid>
      <pubDate>Mon, 13 Oct 2025 12:03:19 GMT</pubDate>
    </item>
    <item>
      <title>OpenAI 消灭了廉价的 ChatGPT 包装器……真的吗？</title>
      <link>https://www.reddit.com/r/programming/comments/1o5h5sv/openai_killed_off_cheap_chatgpt_wrappers_or_did_it/</link>
      <description><![CDATA[在上周的开发日会议上发布的一项重大公告中，OpenAI 推出了 AgentKit，这是一套新的工具，旨在更轻松地构建代理工作流程。 这对于任何在 OpenAI 平台上构建产品的人来说意味着什么？ OpenAI 正在与我们竞争吗？ 我们应该感到兴奋、担心还是忽略炒作？ 让我们深入探讨。   由   提交/u/shift_devs  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5h5sv/openai_killed_off_cheap_chatgpt_wrappers_or_did_it/</guid>
      <pubDate>Mon, 13 Oct 2025 11:30:57 GMT</pubDate>
    </item>
    <item>
      <title>I 代表意图</title>
      <link>https://www.reddit.com/r/programming/comments/1o5ei8e/i_is_for_intent/</link>
      <description><![CDATA[ 由   提交/u/roman01la  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5ei8e/i_is_for_intent/</guid>
      <pubDate>Mon, 13 Oct 2025 08:53:05 GMT</pubDate>
    </item>
    <item>
      <title>软件工程中的无过失文化</title>
      <link>https://www.reddit.com/r/programming/comments/1o5czje/blameless_culture_in_software_engineering/</link>
      <description><![CDATA[ 由   提交/u/thehuslingengineer  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5czje/blameless_culture_in_software_engineering/</guid>
      <pubDate>Mon, 13 Oct 2025 07:14:35 GMT</pubDate>
    </item>
    <item>
      <title>用于可验证 HTTP 的 zkTLS — 停止盲目信任 AI 代理和预言机</title>
      <link>https://www.reddit.com/r/programming/comments/1o5bxsd/zktls_for_verifiable_http_stop_blindly_trusting/</link>
      <description><![CDATA[当您与法学硕士进行氛围编码时，您经常会听到：  法学硕士说：“✅ 我发送了请求。” 预言家说：“✅ 这是真实的数据。”  但是……您如何验证 真的发生过吗？你没有。你只是盲目信任。 😬 这不仅仅是一个 LLM 问题——人类也会这样做。如果没有证据，信任就会脆弱。 这就是为什么我们构建VEFAS（人工智能代理的可验证执行框架）改变了这一点。我们使用 zkTLS 将任何 HTTP(S) 请求转换为 加密证明：  在时间T，我通过真正的TLS将请求X发送到URL Y并得到响应Z。   ❌没有公证人 ❌没有可信网关 ✅任何人都可以验证证明  这是第一个 更大的可验证人工智能堆栈的一层。 该项目是开源，正在大力开发，我们邀请开发人员、密码学家和人工智能构建者来帮助推动这一进程。   由   提交/u/bryanlee9889  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5bxsd/zktls_for_verifiable_http_stop_blindly_trusting/</guid>
      <pubDate>Mon, 13 Oct 2025 06:09:58 GMT</pubDate>
    </item>
    <item>
      <title>Java后端编码技术</title>
      <link>https://www.reddit.com/r/programming/comments/1o5ao8k/java_backend_coding_technology/</link>
      <description><![CDATA[编写 Java 后端代码的新方法。没有“最佳实践”，就没有“干净的代码”。咒语。只是一小部分清晰明确的规则。   由   提交 /u/Zestyclose-Error9313   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5ao8k/java_backend_coding_technology/</guid>
      <pubDate>Mon, 13 Oct 2025 04:55:29 GMT</pubDate>
    </item>
    <item>
      <title>🏛️ 从头开始​​构建法学硕士 – 第 2 部分：数据收集和自定义标记器</title>
      <link>https://www.reddit.com/r/programming/comments/1o56elg/building_llms_from_scratch_part_2_data_collection/</link>
      <description><![CDATA[这是我从头开始构建法学硕士的 4 部分系列的第 2 部分。 第 1 部分介绍了快速入门和整体架构。 在这篇文章中，我将深入探讨任何严肃的 LLM 的基础层：数据收集和 分词器设计。该数据集基于1500-1850 年伦敦的218 个历史来源构建，包括法庭记录、文献、报纸和个人日记。这是超过 5 亿个字符的混乱、不一致且经常被损坏的历史英语。 标准分词器会分割“quoth”和“hast”等古老单词，而扫描文档中的 OCR 错误可能会破坏语义连贯性。这篇文章将指导您完成构建可处理 PDF、HTML、XML 和 TXT 文件的模块化、格式感知管道的过程。它解释了如何使用 30,000 个词汇和超过 150 个特殊标记来训练自定义 BPE 标记器，以保持语言真实性。 当然，这是一个玩具示例，尽管是一个完整的 LLM，旨在帮助人们理解和学习基本原理。现实世界的实现要复杂得多。我还在博文中阐述了这些观点。 🔍 内容  218+ 历史来源：从 Old Bailey 试验到 17 世纪文学  5 阶段清理管道：OCR 校正、编码修复和特定于格式的提取  自定义 分词器：根据古老英语和伦敦特定术语进行训练的 BPE 分词器  质量验证：平衡真实性与训练质量的多层评分  技术实现： 用于处理 PDF、HTML、XML 和 TXT 的代码 分词器 使用 Hugging Face 进行训练 质量评分和验证框架 用于数据摄取和报告的模块化架构   资源  第 2 部分：数据收集和数据收集分词器 第 1 部分讨论 GitHub 代码库 LinkedIn 发布（如果您喜欢的话）  下一步：第 3 部分将介绍模型架构、GPU 优化和训练基础设施。   由   提交/u/amitbahree  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o56elg/building_llms_from_scratch_part_2_data_collection/</guid>
      <pubDate>Mon, 13 Oct 2025 01:20:13 GMT</pubDate>
    </item>
    <item>
      <title>在高层跟踪系统调用</title>
      <link>https://www.reddit.com/r/programming/comments/1o53kpg/tracing_the_syscall_on_a_high_level/</link>
      <description><![CDATA[曾经在 Python 中调用 f.write() 并想知道实际上击中金属的是什么。假设您正在编写一个涉及写入文件的 python 函数。您是否想知道编写该函数时内核级别会发生什么？让我们跟踪一个函数调用，直到它进入内核级别 先决条件  用户空间和内核空间：Linux 以两种模式运行应用程序，一种是权限最高的内核模式，一种是权限最小的用户模式。在内核模式下运行的系统调用是理解它们如何跟踪的重要先决条件 陷阱：Linux 内核中有一种称为陷阱的东西。这有点像同步 CPU 异常，我们将控制权从用户空间转移到内核空间。这些与中断不同，中断是异步的并且来自硬件   注意：这只是 write 系统调用的高级跟踪，还有很多深度需要介绍，但它是理解系统调用执行的一个很好的介绍。 []() []()   由   提交 /u/killer-resume   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o53kpg/tracing_the_syscall_on_a_high_level/</guid>
      <pubDate>Sun, 12 Oct 2025 23:04:09 GMT</pubDate>
    </item>
    <item>
      <title>C++23：从命令式循环到声明性范围</title>
      <link>https://www.reddit.com/r/programming/comments/1o53cyk/c23_from_imperative_loops_to_declarative_ranges/</link>
      <description><![CDATA[ 由   提交 /u/alefore   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o53cyk/c23_from_imperative_loops_to_declarative_ranges/</guid>
      <pubDate>Sun, 12 Oct 2025 22:54:29 GMT</pubDate>
    </item>
    </channel>
</rss>