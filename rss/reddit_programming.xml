<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Mon, 13 Oct 2025 18:23:50 GMT</lastBuildDate>
    <item>
      <title>Redis 上运行的 Lua 脚本存在严重漏洞 - CVE-2025-49844</title>
      <link>https://www.reddit.com/r/programming/comments/1o5rmrn/critical_vulnerability_in_lua_scripts_run_on/</link>
      <description><![CDATA[我想知道你们对将脚本语言引入键值存储以便您可以“高效且原子地在 Redis 中执行部分应用程序逻辑”的整个想法有何看法。   由   提交/u/matt_112358  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5rmrn/critical_vulnerability_in_lua_scripts_run_on/</guid>
      <pubDate>Mon, 13 Oct 2025 18:18:15 GMT</pubDate>
    </item>
    <item>
      <title>测试并不能证明代码是正确的……他们只是同意它</title>
      <link>https://www.reddit.com/r/programming/comments/1o5rh32/tests_dont_prove_code_is_correct_they_just_agree/</link>
      <description><![CDATA[“测试并不能证明某件事是正确的，而是证明一段代码的行为方式与另一段代码认为它应该行为的方式相同。” 有一天，我在编写一些“完美通过”的测试时突然想到了这个想法。我意识到他们实际上并没有证明任何东西——只是确认我在两个地方的假设是匹配的。 当你的实现和测试都有相同的错误假设时，一切仍然会通过。绿色复选标记，虚假信心。 这让我重新思考测试的用途。它们并不是真正要证明真理——更多的是要锁定意图。一种说法是，“如果我改变这种行为，我想知道。” 棘手的部分是意图本身可能是错误的。 无论如何，这只是太多追求 100% 覆盖率的深夜的随机反映。很好奇你们都怎么想的——你们认为测试是验证、文档，还是只是控制混乱的护栏？   由   提交 /u/untypedfuture   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5rh32/tests_dont_prove_code_is_correct_they_just_agree/</guid>
      <pubDate>Mon, 13 Oct 2025 18:12:44 GMT</pubDate>
    </item>
    <item>
      <title>基于行的 Lisp 编辑</title>
      <link>https://www.reddit.com/r/programming/comments/1o5res3/linebased_lisp_editing/</link>
      <description><![CDATA[ 由   提交/u/aartaka  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5res3/linebased_lisp_editing/</guid>
      <pubDate>Mon, 13 Oct 2025 18:10:27 GMT</pubDate>
    </item>
    <item>
      <title>学习编程语言的方法</title>
      <link>https://www.reddit.com/r/programming/comments/1o5re5y/way_to_learn_a_programming_language/</link>
      <description><![CDATA[我遵循这个建议：   我真的很喜欢 PHP。它随着时间的推移不断发展，同时保持语法简洁。然而，我想发现隐藏在引擎盖下的东西。实际上，我正在听从朋友的建议，用 C++ 编写解释器。 我真心推荐这种体验。它改变了您看待编程的方式。 我已经给我的解释器起了一个名字。它被称为 Jim PHP，以纪念由 antirez (Salvatore Sanfilippo) 创建的 Jim Tcl。 这是我到目前为止所做的： Jim PHP 架构分为 3 个级别。每个级别都是一个对象，这三个对象将相互通信。  LEXER：将 PHP 代码拆分为令牌。 PARSER：将从令牌构建 AST。 INTERPRETER：将分析 AST 并执行节点。  注意：Jim PHP 将使用 AST 和 不是像 Jim Tcl 那样面向运行时的解释器。此外，Lexer 遵循共同的理念，但 Parser 和 Interpreter 可能会遵循不同的想法。 DAY ZERO 设置 Git 和 GitHub，研究总体架构，编写 README 文件，并配置 CMakeLists.txt。我花了更多时间来理解架构概念。 第一天 我开始研究如何使用 Jim PHP 执行 PHP 代码。 与 Jim Tcl 一样，Jim PHP 可以通过 3 种方式运行代码：  硬编码/内联字符串：std::string php_code = &quot;1+1;&quot;; 从命令行：jimphp -r &#39;echo 1+1;&#39; 从文件：jimphp sum.php  注意：要执行命令，Jim PHP 将使用 jimphp 命令，与 Jim Tcl 不同，它使用 jimsh*。这是因为我希望它与 PHP 类似。* 我首先采用硬编码字符串方法，用其标记结构启动 Lexer 实现。 根据我的研究，Lexer 的工作是获取整个源代码并将其拆分为单独的标记。这些标记将在下一步中用于构建解析器，然后构建解释器。 Lexer.cpp 现在可以对表达式进行标记。 “1+1”变为“1”、“+”、“1”。 第二天 开始修复 Lexer.cpp 中的一些问题。 问题 #1： 如果您像这样在 main.cpp 中硬编码 PHP 代码： std::string php_code = “(10.2+0.5*(2-0.4))*2+(2.1*4)”; 词法分析器将返回一个“未知字符”错误，因为它当然不会自动识别像 () {} 这样的符号。 昨天，Jim PHP 只用像“1+1”这样的简单表达式进行了测试，这是不够的。需要处理复杂的PHP代码，所以一个更好的词法分析器，能够更准确地标记和更精确地识别符号是绝对必要的。 也许我有点得意忘形，但Jim PHP现在不仅可以识别某些特殊字符，而且还可以根据我自己的（可能过于精确的）逻辑对它们进行分类和结构。 标记结构如下： Token(const std::string&amp; t, const std::string&amp; v) // 类型（类别名称）和值：type(t), value(v) {}  这样，可以更好地组织标记：  Char 标记：a-z、A-Z 和 _ Num 标记：0-9 Punct（标点符号）标记：., ,, :, ; Oper（运算符）标记：+、-、*、/、=、%、^ Parent（括号）标记：()、[]、{} Scahr（特殊字符）标记：!, @、#、$、 &amp;、?、&lt;、&gt;、\、|、&#39;、&quot;和 ==、!=、&gt;=、&lt;=、&amp;&amp;、||  这样，我们就可以编写更复杂的 PHP 表达式，如： std::string php_code = &quot;$hello = 5.5 + 10 * (3 - 1); // 测试！ @#|_\\“” 结果：  SCHAR：$ CHAR：hello_user OPER：= NUM：5 PUNCT：. NUM：5 OPER：+ NUM： 10 OPER: * LPAREN: ( NUM: 3 OPER: - NUM: 1 RPAREN: ) PUNCT: ; OPER: / OPER: / CHAR: 测试 SCHAR: ! SCHAR: @ SCHAR: # SCHAR: | CHAR: _ SCHAR: \ SCHAR: &quot;  这是一个好方法吗？    由   提交/u/Giuseppe_Puleri   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5re5y/way_to_learn_a_programming_language/</guid>
      <pubDate>Mon, 13 Oct 2025 18:09:54 GMT</pubDate>
    </item>
    <item>
      <title>《星际迷航》中没有程序员</title>
      <link>https://www.reddit.com/r/programming/comments/1o5rdyg/there_are_no_programmers_in_star_trek/</link>
      <description><![CDATA[ 由   提交/u/Active-Fuel-49   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5rdyg/there_are_no_programmers_in_star_trek/</guid>
      <pubDate>Mon, 13 Oct 2025 18:09:42 GMT</pubDate>
    </item>
    <item>
      <title>到 2025 年，RAD 对 Java 开发人员仍然有意义吗？</title>
      <link>https://www.reddit.com/r/programming/comments/1o5q951/does_rad_still_make_sense_in_2025_for_java/</link>
      <description><![CDATA[最近，我一直在重新审视快速应用程序开发 (RAD) 工具，这些工具专注于以最少的样板快速生成完整的 CRUD 应用程序。 在 Java 世界中，我们有 WaveMaker、OpenXava、OutSystems、Oracle APEX 和 Jmix 等框架，每个框架都采用不同的方法。 但现在 AI 工具几乎可以立即生成 Spring Boot + Angular 代码，我想知道： RAD 在 2025 年是否仍然占有一席之地，或者 GenAI 是否会使其过时？ 好奇其他人的想法 - 特别是那些同时使用 RAD 框架和传统 Java 堆栈的人。   由   提交/u/Competitive-Fee-2503   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5q951/does_rad_still_make_sense_in_2025_for_java/</guid>
      <pubDate>Mon, 13 Oct 2025 17:29:47 GMT</pubDate>
    </item>
    <item>
      <title>技术债务：让开发人员现在更快乐，或者以后付出更多</title>
      <link>https://www.reddit.com/r/programming/comments/1o5nnoe/technical_debt_make_developers_happier_now_or_pay/</link>
      <description><![CDATA[ 由   提交/u/nosoyjohn  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5nnoe/technical_debt_make_developers_happier_now_or_pay/</guid>
      <pubDate>Mon, 13 Oct 2025 15:57:35 GMT</pubDate>
    </item>
    <item>
      <title>使用 Swift Subprocess 自动化所有事情</title>
      <link>https://www.reddit.com/r/programming/comments/1o5nm1t/automate_all_the_things_with_swift_subprocess/</link>
      <description><![CDATA[ 由   提交/u/jacobs-tech-tavern   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5nm1t/automate_all_the_things_with_swift_subprocess/</guid>
      <pubDate>Mon, 13 Oct 2025 15:55:58 GMT</pubDate>
    </item>
    <item>
      <title>Python 3.14 的 7 个关键更新让您的编码更轻松、更快、更好</title>
      <link>https://www.reddit.com/r/programming/comments/1o5lp3s/7_key_python_314_updates_to_make_your_coding/</link>
      <description><![CDATA[ 由   提交/u/wyhjsbyb   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5lp3s/7_key_python_314_updates_to_make_your_coding/</guid>
      <pubDate>Mon, 13 Oct 2025 14:46:09 GMT</pubDate>
    </item>
    <item>
      <title>如何使用人工智能帮助完成软件工程任务</title>
      <link>https://www.reddit.com/r/programming/comments/1o5kmc5/how_to_use_ai_to_help_with_software_engineering/</link>
      <description><![CDATA[ 由   提交 /u/gregorojstersek   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5kmc5/how_to_use_ai_to_help_with_software_engineering/</guid>
      <pubDate>Mon, 13 Oct 2025 14:04:53 GMT</pubDate>
    </item>
    <item>
      <title>汇编编程是残酷的，也是美丽的，甚至可能是通往更好人工智能的道路</title>
      <link>https://www.reddit.com/r/programming/comments/1o5jq1w/programming_in_assembly_is_brutal_beautiful_and/</link>
      <description><![CDATA[ 由   提交/u/wiredmagazine  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5jq1w/programming_in_assembly_is_brutal_beautiful_and/</guid>
      <pubDate>Mon, 13 Oct 2025 13:28:29 GMT</pubDate>
    </item>
    <item>
      <title>环境变量是一个遗留的混乱：让我们深入研究它们</title>
      <link>https://www.reddit.com/r/programming/comments/1o5j78b/environment_variables_are_a_legacy_mess_lets_dive/</link>
      <description><![CDATA[ 由   提交/u/Low-Strawberry7579  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5j78b/environment_variables_are_a_legacy_mess_lets_dive/</guid>
      <pubDate>Mon, 13 Oct 2025 13:06:30 GMT</pubDate>
    </item>
    <item>
      <title>原子幂等性：精确一次执行的实用方法</title>
      <link>https://www.reddit.com/r/programming/comments/1o5huwk/atomic_idempotency_a_practical_approach_to/</link>
      <description><![CDATA[ 由   提交 /u/ymz-ncnk   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5huwk/atomic_idempotency_a_practical_approach_to/</guid>
      <pubDate>Mon, 13 Oct 2025 12:06:20 GMT</pubDate>
    </item>
    <item>
      <title>了解 Go 中的适配器设计模式：实用指南</title>
      <link>https://www.reddit.com/r/programming/comments/1o5hsqh/understanding_the_adapter_design_pattern_in_go_a/</link>
      <description><![CDATA[嘿伙计们， 我刚刚写完一篇关于 Go 中的适配器设计模式的深入博客 - 这种模式乍一看很简单，但实际上在集成遗留系统或第三方系统时可以节省您的理智。 这篇文章涵盖了从基础知识到实际代码示例的所有内容：  如何制作 不兼容的接口可以在不接触旧代码的情况下协同工作 何时实际使用适配器（何时不使用） 类适配器与对象适配器之间的区别 真实世界的示例，例如包装 JSON 记录器或支付 API 常见的反模式（例如“适配器地狱”😅） Go 特定的习惯用法： 轻量级、界面驱动且干净  如果您曾经发现自己编写丑陋的粘合代码只是为了让两个系统进行对话 - 这就是为您准备的。 🔗 阅读此处： https://medium.com/design-bootcamp/understanding-the-adapter-design-pattern-in-go-a-practical-guide-a595b256a08b 很想听听您如何处理 Go 中的遗留集成或 SDK 不匹配问题 - 您使用适配器还是进行完全重写？   由   提交/u/priyankchheda15   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5hsqh/understanding_the_adapter_design_pattern_in_go_a/</guid>
      <pubDate>Mon, 13 Oct 2025 12:03:19 GMT</pubDate>
    </item>
    <item>
      <title>OpenAI 消灭了廉价的 ChatGPT 包装器……真的吗？</title>
      <link>https://www.reddit.com/r/programming/comments/1o5h5sv/openai_killed_off_cheap_chatgpt_wrappers_or_did_it/</link>
      <description><![CDATA[在上周的开发日会议上发布的一项重大公告中，OpenAI 推出了 AgentKit，这是一套新的工具，旨在更轻松地构建代理工作流程。 这对于任何在 OpenAI 平台上构建产品的人来说意味着什么？ OpenAI 正在与我们竞争吗？ 我们应该感到兴奋、担心还是忽略炒作？ 让我们深入探讨。   由   提交/u/shift_devs  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1o5h5sv/openai_killed_off_cheap_chatgpt_wrappers_or_did_it/</guid>
      <pubDate>Mon, 13 Oct 2025 11:30:57 GMT</pubDate>
    </item>
    </channel>
</rss>