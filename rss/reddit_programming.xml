<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Thu, 05 Feb 2026 15:39:50 GMT</lastBuildDate>
    <item>
      <title>为什么人工智能生成的代码会伤害客户和公司</title>
      <link>https://www.reddit.com/r/programming/comments/1qwo8ld/why_aigenerated_code_will_hurt_both_customers_and/</link>
      <description><![CDATA[ 由   提交/u/drakedemon  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwo8ld/why_aigenerated_code_will_hurt_both_customers_and/</guid>
      <pubDate>Thu, 05 Feb 2026 15:27:24 GMT</pubDate>
    </item>
    <item>
      <title>史诗般的逆向工程+编程错误修复。你怎么认为？</title>
      <link>https://www.reddit.com/r/programming/comments/1qwo7k1/epic_reverseengineering_programming_a_bugfix_what/</link>
      <description><![CDATA[我偶然发现了几年前发现的 GTA Online 的 bugix。 对我来说，这是天才的作品，它涉及到所有部分：  检查 假设 逆向工程 在假设下编写 bug 修复程序 二进制修补 测试 bug  你觉得怎么样？   由   提交/u/germandiago  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwo7k1/epic_reverseengineering_programming_a_bugfix_what/</guid>
      <pubDate>Thu, 05 Feb 2026 15:26:21 GMT</pubDate>
    </item>
    <item>
      <title>2026 年颤振状况</title>
      <link>https://www.reddit.com/r/programming/comments/1qwnfm6/state_of_flutter_2026/</link>
      <description><![CDATA[ 由   提交/u/dev_newsletter  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwnfm6/state_of_flutter_2026/</guid>
      <pubDate>Thu, 05 Feb 2026 14:56:45 GMT</pubDate>
    </item>
    <item>
      <title>旧金山首届官方 ClawCon</title>
      <link>https://www.reddit.com/r/programming/comments/1qwn8lh/the_first_official_clawcon_in_sf/</link>
      <description><![CDATA[ 由   提交/u/Dheeruj   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwn8lh/the_first_official_clawcon_in_sf/</guid>
      <pubDate>Thu, 05 Feb 2026 14:48:59 GMT</pubDate>
    </item>
    <item>
      <title>多模式提示注入：多语言 SVG 对 AI 的攻击</title>
      <link>https://www.reddit.com/r/programming/comments/1qwlx0c/multimodal_prompt_injection_the_polyglot_svg/</link>
      <description><![CDATA[ 由   提交/u/JadeLuxe  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwlx0c/multimodal_prompt_injection_the_polyglot_svg/</guid>
      <pubDate>Thu, 05 Feb 2026 13:55:20 GMT</pubDate>
    </item>
    <item>
      <title>我需要一台食品追踪机</title>
      <link>https://www.reddit.com/r/programming/comments/1qwlpyv/i_need_a_food_tracking_machine/</link>
      <description><![CDATA[这是一篇一团糟的帖子，所以请随意忽略这一点，我在第 2 段中的真正观点 （还有 url 的事情？？？） 所以我目前正在吃食物，这听起来很奇怪，但我认为我的很多身体和精神问题都是因为我吃的食物和质量（加上我想减肥，但也达到了我的每日任务）无论如何，而不仅仅是减少卡路里我对获得每日营养配额很感兴趣。我是素食主义者，吃得像垃圾一样，谁能想到，我会随机感到极大的疲劳和身体疼痛。我也有很多健康意识，因为虽然我没有任何问题 - 我知道 - 它很容易成为发展中的问题。但当我真正开始制作一份关于蛋白质（必需氨基酸）、维生素矿物质的每日配额的 Excel 表格时，我意识到这么多食物对你来说是多么垃圾，因为它缺乏我所消耗的每克营养密度和卡路里。我对预算也很陌生，所以需要知道我需要多少食物，我需要吃多少食物，这样当我上大学时，我就可以吃我公关计划的食物，而不必担心它，并知道我得到了一切。  自从我也重新开始编程以来，我想我可以制作一个东西，可以浏览我发现的某些网页，其中包含有关食物组的营养详细信息，然后对其进行组织，按价格范围对其进行过滤，并制定各种类似每日计划的各种食物组合，我可以在一天中吃到每天的食物。我可能最终会手动完成此操作，但制作维生素和矿物质表已经足够困难了，因此任何最终制作某种网页、Excel 甚至应用程序的方法，我都洗耳恭听   由   提交/u/CalendarUsed2597   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwlpyv/i_need_a_food_tracking_machine/</guid>
      <pubDate>Thu, 05 Feb 2026 13:47:15 GMT</pubDate>
    </item>
    <item>
      <title>解决“AI失忆症”：为LLM辅助工程构建持久状态层</title>
      <link>https://www.reddit.com/r/programming/comments/1qwli9z/solving_ai_amnesia_building_a_persistent_state/</link>
      <description><![CDATA[嘿r/programming， 我一直在研究“上下文漂移”问题在人工智能辅助编码中。即使使用像 Cursor 或 Claude Code 这样的工具，也存在一个反复出现的问题：随着项目规模的扩大，人工智能开始“产生幻觉”。架构决策或忘记最初的实施计划，导致技术债务在几次迭代后才变得明显。 我构建了 Ultra-Dex 作为 CLI 元层来解决这个问题。我想分享我使用共享内存图来解决跨不同人工智能工具（Claude、GPT、Cursor）的持久上下文的技术方法。 核心技术挑战：  短暂会话状态：法学硕士将每次聊天视为新鲜的石板。为了解决这个问题，我实现了标准化上下文格式（UDCF）。它是一个基于 Markdown 的状态机，CLI 在本地代码库和 LLM 的活动提示之间同步。 架构执行：大多数 AI 代理偏离计划，因为它们缺乏“骨架”。跟随。 Ultra-Dex 使用 34 部分状态感知模板。当代理运行时，CLI 会根据计划部分预先验证代码库，强制代理在生成一行代码之前遵守已建立的模式（例如 Zod 架构或 Prisma 模型）。 “验证”功能循环：构建一个自主的自愈循环。 CLI 实现了一个在 Docker 沙箱中运行的 21 步验证框架。如果测试失败，它不仅仅会显示错误；还会显示错误。它将堆栈跟踪反馈给专门的 @Debugger 代理以尝试自主修复。 通过 MCP 进行多代理编排：我们实现了模型上下文协议 (MCP)，以允许 Cursor 或 Claude Desktop 等工具直接查询项目的内部知识图谱。这将代码库变成了人工智能的可查询数据库。  经验教训：最大的收获是代码生成是容易的部分。困难的部分是代理的状态管理。通过移动“大脑”将项目从 LLM 转移到 CLI 管理的图表中，我们在内部基准测试中将架构漂移减少了约 70%。 我已经开源了编排层和代理层。我很想听听其他人如何在人工智能工作流程中处理架构内存。 技术堆栈： Node.js、TypeScript、Docker（用于沙箱）、用于状态机的 LangGraph。 GitHub： https://github.com/Srujan0798/Ultra-Dex   由   提交/u/Vegetable-Cat114   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwli9z/solving_ai_amnesia_building_a_persistent_state/</guid>
      <pubDate>Thu, 05 Feb 2026 13:38:17 GMT</pubDate>
    </item>
    <item>
      <title>Flow 架构 • Susanne Kaiser 和 James Lewis</title>
      <link>https://www.reddit.com/r/programming/comments/1qwlfvd/architecture_for_flow_susanne_kaiser_james_lewis/</link>
      <description><![CDATA[ 由   提交 /u/goto-con   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwlfvd/architecture_for_flow_susanne_kaiser_james_lewis/</guid>
      <pubDate>Thu, 05 Feb 2026 13:35:27 GMT</pubDate>
    </item>
    <item>
      <title>QRT：屏幕到相机的数据传输协议，使用 QR 码（概念验证）</title>
      <link>https://www.reddit.com/r/programming/comments/1qwl9fh/qrt_a_screentocamera_data_transfer_protocol_using/</link>
      <description><![CDATA[该项目探索使用屏幕到相机的方法进行数据传输。这个想法很简单：将信息编码成一系列二维码，将其作为视频显示在屏幕上，然后使用摄像头捕获和解码视频帧以检索原始数据。   由   提交/u/smyrgeorge  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwl9fh/qrt_a_screentocamera_data_transfer_protocol_using/</guid>
      <pubDate>Thu, 05 Feb 2026 13:27:49 GMT</pubDate>
    </item>
    <item>
      <title>事后分析：我的自动分级启发式建议 526 个文件为“热门”——通过严格的上限 + 确定性评分进行修复</title>
      <link>https://www.reddit.com/r/programming/comments/1qwl0np/postmortem_my_autotier_heuristic_suggested_526/</link>
      <description><![CDATA[事后分析：我尝试对存储库中的“重要上下文”文件进行自动分类。 git-recency-heavy 启发式方法以经典方式失败：它建议 526 个文件应该是“HOT”。修复：硬上限（最大 HOT = 10）+ 确定性评分 + 小型规范集。 证明（2026 年 2 月 5 日，澳大利亚东部时间晚上 11:45）： ✔ 分析了 148 个文件 |热门 1​​0 |温暖 69 | COLD 22 除了 git reency 之外，你会使用什么信号来推断“重要上下文”？   由   提交/u/jantonca  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwl0np/postmortem_my_autotier_heuristic_suggested_526/</guid>
      <pubDate>Thu, 05 Feb 2026 13:17:25 GMT</pubDate>
    </item>
    <item>
      <title>乐观锁定与悲观锁定：并发控制、冲突、更新丢失、重试和阻塞</title>
      <link>https://www.reddit.com/r/programming/comments/1qwkuh4/optimistic_vs_pessimistic_locking_concurrency/</link>
      <description><![CDATA[在许多应用程序和系统中，我们必须处理并发的、经常发生冲突且可能丢失的更新。这正是并发控制问题的全部内容。忽略它意味着许多错误、困惑的用户和损失金钱。避免所有这些事情肯定是更好的选择！ 因此，解决并发问题的第一个解决方案是乐观的。 我们假设我们的更新不会与其他更新冲突；如果确实如此，则会引发异常，并将处理留给用户/客户端。由他们决定是重试还是完全放弃操作。 如何检测此类冲突？ 必须有一种方法来确定记录是否在我们处理记录的同时被修改。为此，我们添加一个简单的数字版本列，并按如下方式使用： UPDATE Campaign SET预算 = 1000, version = version + 1 WHERE id = 1 AND version = 1;  每次修改活动实体时，其版本也会增加；此外，版本值（在事务开始时已知，在更新语句之前获取）被添加到 where 子句中。大多数语言的大多数数据库驱动程序都支持从数据操作语言 (DML) 语句（如 UPDATE）返回受影响的行数；在我们的例子中，我们期望得到恰好一个受影响的行。如果情况并非如此，则意味着该版本是由另一个并行运行的查询增加的 - 可能存在冲突！在这种情况下，我们只需抛出某种OptimisticLockException。 结果：  没有冲突的更新 - 如果实体在此期间被修改，如意外更改的版本值通知，操作将中止 用户/客户端决定如何处理中止的操作 - 他们可能会刷新页面，看到数据变化，判断现在已经好了，不需要修改；或者他们可能会以相同或不同的方式修改它，但要点是：没有一个更新丢失  因此，并发问题的第二种解决方案是悲观的。 我们预先假设会发生冲突，并在所需的时间内锁定修改的记录。 对于此策略，无需以任何方式修改架构。要使用它，我们只需悲观地在事务持续时间内锁定正在修改的行。触发预算修改的点击示例： -- click1 是第一个 -- BEGIN;从预算中选择 *，其中 id = 1 进行更新；更新预算 SET available_amount = 50 WHERE id = 1;犯罪; -- 并行单击2，但第二次 -- BEGIN; -- 交易在此锁定，直到 click1 交易结束 -- SELECT * FROM Budget WHERE id = 1 FOR UPDATE; -- 在 click1 事务提交/回滚后，事务在此处恢复， -- -- 始终保持最新的预算 -- 更新预算 -- 值正确设置为 0，因为我们始终获得最新的预算 -- SET available_amount = 0 WHERE id = 1;犯罪;  结果：  在任何给定时间只有一个更新执行 - 如果另一个进程尝试更改同一实体，则会被阻止；然后，该进程必须等到第一个进程结束并释放锁 我们总是获取最新数据 - 每个进程首先（尝试）锁定实体，然后才修改它 客户端/用户不知道并行的、潜在冲突的更新 - 每个进程首先获取实体上的锁，但没有直接的方法知道同时发生了冲突的更新；我们只需等待轮到我们  有趣的是，还可以使用悲观锁来模拟一些乐观锁定功能 - 使用 NOWAIT 和 SKIP LOCKED SQL 子句:)   由   提交 /u/BinaryIgor   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwkuh4/optimistic_vs_pessimistic_locking_concurrency/</guid>
      <pubDate>Thu, 05 Feb 2026 13:09:37 GMT</pubDate>
    </item>
    <item>
      <title>Elm 入门：与 MutationObserver 的声明式对话 · cekrem.github.io</title>
      <link>https://www.reddit.com/r/programming/comments/1qwkt6y/an_elm_primer_declarative_dialogs_with/</link>
      <description><![CDATA[ 由   提交 /u/cekrem   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwkt6y/an_elm_primer_declarative_dialogs_with/</guid>
      <pubDate>Thu, 05 Feb 2026 13:08:00 GMT</pubDate>
    </item>
    <item>
      <title>良好激励的 3 个原则</title>
      <link>https://www.reddit.com/r/programming/comments/1qwjrts/3_principles_of_good_incentives/</link>
      <description><![CDATA[ 由   提交/u/dmp0x7c5  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwjrts/3_principles_of_good_incentives/</guid>
      <pubDate>Thu, 05 Feb 2026 12:18:24 GMT</pubDate>
    </item>
    <item>
      <title>Redis 将如何杀死您的数据库（以及如何阻止它）</title>
      <link>https://www.reddit.com/r/programming/comments/1qwj6an/how_redis_will_kill_your_database_and_how_to_stop/</link>
      <description><![CDATA[ 由   提交 /u/SevereGolf3232   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwj6an/how_redis_will_kill_your_database_and_how_to_stop/</guid>
      <pubDate>Thu, 05 Feb 2026 11:47:11 GMT</pubDate>
    </item>
    <item>
      <title>我厌倦了通用的速度测试，所以我构建了自己的 WP 审核工具。</title>
      <link>https://www.reddit.com/r/programming/comments/1qwig9p/i_got_tired_of_generic_speed_tests_so_i_built_my/</link>
      <description><![CDATA[ 由   提交/u/AlternativeYou4536   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1qwig9p/i_got_tired_of_generic_speed_tests_so_i_built_my/</guid>
      <pubDate>Thu, 05 Feb 2026 11:07:27 GMT</pubDate>
    </item>
    </channel>
</rss>